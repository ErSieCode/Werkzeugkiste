<!DOCTYPE html>
<html lang="de" manifest="cache.manifest">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0084b4">
    <meta name="description" content="Professionelle Navigations- und Sicherheits-App f√ºr Hochseeangeln bei Leka, Norwegen">
    <title>Hochseeangeln Leka - Navigations- & Sicherheits-App</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <style>
        /* Critical CSS for immediate rendering */
        :root {
            --primary-blue: #0084b4;
            --primary-blue-light: #1a9bcf;
            --primary-green: #2d5a27;
            --primary-green-light: #4a7c59;
            --bg-dark: #1a1a1a;
            --bg-medium: #2d2d2d;
            --bg-light: #3a3a3a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-muted: #808080;
            --accent-orange: #ff6b35;
            --accent-red: #e74c3c;
            --accent-green: #27ae60;
            --accent-yellow: #f39c12;
            --accent-purple: #9b59b6;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 8px rgba(0,0,0,0.15);
            --shadow-lg: 0 8px 16px rgba(0,0,0,0.2);
            --border-radius: 8px;
            --transition-fast: 0.2s ease;
            --transition-smooth: 0.3s ease;
            --tide-high: #3498db;
            --tide-low: #e67e22;
            --safe-area-inset-top: env(safe-area-inset-top);
            --safe-area-inset-bottom: env(safe-area-inset-bottom);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-dark), var(--bg-medium));
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
            padding-top: var(--safe-area-inset-top);
        }

        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            min-height: 100vh;
            padding-bottom: calc(1rem + var(--safe-area-inset-bottom));
        }

        /* Header */
        .app-header {
            background: linear-gradient(135deg, var(--primary-blue), var(--primary-blue-light));
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-lg);
            text-align: center;
            position: relative;
        }

        .app-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .app-subtitle {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 300;
        }

        /* Sync Status Indicator */
        .sync-status {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0,0,0,0.3);
            padding: 0.5rem 1rem;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
        }

        .sync-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse 2s infinite;
        }

        .sync-indicator.syncing {
            background: var(--accent-yellow);
            animation: pulse 1s infinite;
        }

        .sync-indicator.error {
            background: var(--accent-red);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }

        /* Navigation */
        .nav-tabs {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .nav-tab {
            background: rgba(255,255,255,0.1);
            border: none;
            color: var(--text-primary);
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all var(--transition-fast);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            backdrop-filter: blur(10px);
            position: relative;
            -webkit-tap-highlight-color: transparent;
            font-size: inherit;
        }

        .nav-tab:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .nav-tab.active {
            background: var(--accent-orange);
            box-shadow: var(--shadow-md);
        }

        .nav-tab .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--accent-red);
            color: white;
            font-size: 0.7rem;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-weight: bold;
        }

        /* Content Sections */
        .content-container {
            display: grid;
            gap: 1rem;
        }

        .content-section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .content-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-light);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: var(--shadow-md);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-blue-light);
        }

        /* Map Container */
        .map-container {
            position: relative;
            height: 70vh;
            min-height: 500px;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            background: var(--bg-medium);
            touch-action: none;
        }

        .map-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            transition: opacity var(--transition-smooth);
        }

        .map-layer.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #leafletMap {
            z-index: 1;
        }

        #kystinfoFrame {
            z-index: 2;
        }

        #pdfViewer {
            z-index: 3;
            background: white;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #pdfCanvas {
            cursor: grab;
            transition: none;
            max-width: 100%;
            max-height: 100%;
        }

        #pdfCanvas.grabbing {
            cursor: grabbing;
        }

        .pdf-controls {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background: rgba(0,0,0,0.8);
            border-radius: var(--border-radius);
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
            z-index: 10;
        }

        .pdf-zoom-btn {
            background: var(--bg-medium);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all var(--transition-fast);
        }

        .pdf-zoom-btn:hover {
            background: var(--bg-light);
        }

        .pdf-zoom-btn:active {
            transform: scale(0.95);
        }

        /* GPS Track Overlay */
        .gps-track-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .gps-track-svg {
            width: 100%;
            height: 100%;
        }

        .marker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99;
        }

        .overlay-marker {
            position: absolute;
            width: 30px;
            height: 30px;
            background: var(--accent-orange);
            border: 3px solid white;
            border-radius: 50% 50% 50% 0;
            transform: translate(-50%, -100%) rotate(-45deg);
            box-shadow: var(--shadow-md);
            pointer-events: auto;
            cursor: pointer;
        }

        .overlay-marker.favorite {
            background: gold;
        }

        .overlay-marker-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        /* GPS Precision Indicator - Separate positioniert */
        .gps-precision {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: var(--border-radius);
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        
        @media (max-width: 768px) {
            .gps-precision {
                top: auto;
                bottom: 8rem;
                right: 0.5rem;
                left: auto;
                font-size: 0.75rem;
                padding: 0.4rem 0.75rem;
            }
        }

        .precision-bar {
            width: 100px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin-top: 0.25rem;
            overflow: hidden;
        }

        .precision-fill {
            height: 100%;
            background: var(--accent-green);
            transition: width 0.3s ease;
        }

        /* GPS Info Panel */
        .gps-info-panel {
            position: absolute;
            top: 10rem;
            left: 1rem;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 1rem;
            border-radius: var(--border-radius);
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
            max-width: 250px;
        }

        .gps-info-panel.active {
            display: block;
        }

        .gps-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
            gap: 1rem;
        }

        .gps-info-label {
            color: var(--text-secondary);
        }

        .gps-info-value {
            font-weight: 600;
            font-family: monospace;
        }

        /* Map Controls */
        .map-controls {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 1000;
        }

        .map-overlay {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: calc(100% - 80px);
        }

        /* Einzelne Overlay-Elemente */
        .map-overlay > * {
            backdrop-filter: blur(10px);
        }

        /* GPS Status Display */
        .gps-status {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            min-width: 200px;
        }

        .gps-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #808080;
            transition: all var(--transition-fast);
            flex-shrink: 0;
        }

        .gps-indicator.active {
            background: #27ae60;
            box-shadow: 0 0 8px rgba(39, 174, 96, 0.8);
            animation: pulse 2s infinite;
        }

        .gps-indicator.tracking {
            background: #f39c12;
            box-shadow: 0 0 8px rgba(243, 156, 18, 0.8);
            animation: pulse 1s infinite;
        }

        .gps-indicator.error {
            background: #e74c3c;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.8);
        }

        .gps-status-text {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Map Layers Selector */
        .layer-selector {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.5rem;
            border-radius: var(--border-radius);
            backdrop-filter: blur(10px);
        }

        .layer-selector select {
            background: transparent;
            color: white;
            border: none;
            font-size: 0.9rem;
            cursor: pointer;
            outline: none;
            padding: 0.25rem;
        }

        .layer-selector select option {
            background: var(--bg-dark);
            color: white;
        }

        /* Tide Display */
        .tide-display {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: var(--border-radius);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .tide-icon {
            font-size: 1.2rem;
        }

        .tide-status {
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }

        .tide-main {
            font-weight: 600;
        }

        .tide-next {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Position Selector */
        .position-selector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-light);
            border-radius: var(--border-radius);
            padding: 2rem;
            box-shadow: var(--shadow-lg);
            z-index: 10000;
            display: none;
            max-width: 400px;
            width: 90%;
        }

        .position-selector.active {
            display: block;
            animation: modalSlideIn 0.3s ease;
        }

        .position-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .position-option {
            background: var(--bg-medium);
            border: 2px solid transparent;
            border-radius: var(--border-radius);
            padding: 1rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .position-option:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
        }

        .position-option-icon {
            font-size: 2rem;
        }

        .position-option-text h4 {
            margin-bottom: 0.25rem;
            color: var(--primary-blue-light);
        }

        .position-option-text p {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Weather Widget */
        .weather-widget {
            background: linear-gradient(135deg, var(--primary-green), var(--primary-green-light));
            border-radius: var(--border-radius);
            padding: 1.5rem;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .weather-alert {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: var(--accent-red);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: var(--border-radius);
            font-size: 0.8rem;
            font-weight: 600;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .weather-main {
            display: flex;
            align-items: center;
            justify-content: space-around;
            margin-bottom: 1rem;
        }

        .weather-current {
            text-align: center;
        }

        .weather-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .weather-temp {
            font-size: 2.5rem;
            font-weight: 700;
        }

        .weather-condition {
            font-size: 1rem;
            opacity: 0.9;
        }

        .weather-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .weather-detail {
            background: rgba(0,0,0,0.2);
            padding: 0.75rem;
            border-radius: var(--border-radius);
            text-align: center;
        }

        .weather-detail-icon {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
            display: block;
        }

        .weather-detail-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .weather-detail-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* Tide Chart */
        .tide-chart {
            background: var(--bg-medium);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-top: 1rem;
        }

        .tide-chart-canvas {
            width: 100%;
            height: 200px;
        }

        /* Fish Species Grid */
        .fish-species-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .fish-species-item {
            background: var(--bg-medium);
            border: 2px solid transparent;
            border-radius: var(--border-radius);
            padding: 0.75rem;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .fish-species-item:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
        }

        .fish-species-item.selected {
            border-color: var(--accent-green);
            background: rgba(39, 174, 96, 0.1);
        }

        .fish-species-icon {
            font-size: 2rem;
            margin-bottom: 0.25rem;
        }

        .fish-species-name {
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Emergency Button */
        .emergency-button {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--accent-red);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: var(--shadow-lg);
            cursor: pointer;
            z-index: 9999;
            animation: emergencyPulse 2s infinite;
            border: none;
        }

        @keyframes emergencyPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.4); }
            50% { box-shadow: 0 0 0 20px rgba(231, 76, 60, 0); }
        }

        /* Modals */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
            padding: 1rem;
            overflow-y: auto;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-light);
            border-radius: var(--border-radius);
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.9) translateY(-20px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            background: var(--bg-medium);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .modal-close:hover {
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
        }

        .modal-body {
            padding: 1.5rem;
        }

        /* Data Status */
        .data-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .status-item {
            background: var(--bg-medium);
            border-radius: var(--border-radius);
            padding: 1rem;
            text-align: center;
            border-left: 4px solid var(--primary-blue);
        }

        .status-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-blue-light);
        }

        .status-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Lists */
        .marker-list, .catch-list {
            display: grid;
            gap: 1rem;
        }

        .marker-item, .catch-item {
            background: var(--bg-medium);
            border-radius: var(--border-radius);
            padding: 1rem;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all var(--transition-fast);
        }

        .marker-item:hover, .catch-item:hover {
            background: var(--bg-light);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .item-title {
            font-weight: 600;
            color: var(--primary-blue-light);
        }

        .item-meta {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .item-meta p {
            margin-bottom: 0.25rem;
        }

        .item-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Buttons */
        .btn {
            background: var(--primary-blue);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-size: 0.9rem;
        }

        .btn:hover {
            background: var(--primary-blue-light);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-icon {
            width: 50px;
            height: 50px;
            padding: 0;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }

        .btn-small {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            border-radius: 4px;
        }

        .btn-success {
            background: var(--accent-green);
        }

        .btn-success:hover {
            background: #2ecc71;
        }

        .btn-secondary {
            background: var(--bg-medium);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-secondary:hover {
            background: var(--bg-light);
        }

        .btn-danger {
            background: var(--accent-red);
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-warning {
            background: var(--accent-yellow);
            color: var(--bg-dark);
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        /* Forms */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-label .required {
            color: var(--accent-red);
        }

        .form-control {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-medium);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: var(--border-radius);
            color: var(--text-primary);
            transition: all var(--transition-fast);
            font-size: 16px;
            font-family: inherit;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(0,132,180,0.1);
        }

        .form-control[readonly] {
            background: var(--bg-dark);
            color: var(--text-muted);
        }

        .form-control.error {
            border-color: var(--accent-red);
        }

        .form-error {
            color: var(--accent-red);
            font-size: 0.875rem;
            margin-top: 0.25rem;
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
        }

        select.form-control {
            cursor: pointer;
        }

        /* GPS Coordinates Display */
        .coords-display {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 0.5rem;
            align-items: center;
        }

        .coords-input {
            font-family: monospace;
            font-size: 0.9rem;
        }

        .coords-copy {
            padding: 0.5rem;
            background: var(--bg-medium);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all var(--transition-fast);
            color: white;
        }

        .coords-copy:hover {
            background: var(--bg-light);
        }

        .coords-copy.copied {
            background: var(--accent-green);
        }

        /* Route Statistics */
        .route-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            background: var(--bg-medium);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-top: 1rem;
        }

        .route-stat {
            text-align: center;
            padding: 0.5rem;
            border-right: 1px solid rgba(255,255,255,0.1);
        }

        .route-stat:last-child {
            border-right: none;
        }

        .route-stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-blue-light);
        }

        .route-stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Weather Summary */
        .weather-summary {
            background: var(--bg-medium);
            padding: 0.5rem;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Photo Preview */
        #photoPreview {
            margin-top: 0.5rem;
        }

        #photoPreview img {
            max-width: 100%;
            max-height: 200px;
            border-radius: var(--border-radius);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20000;
            flex-direction: column;
            gap: 1rem;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: white;
            font-size: 1.1rem;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
            max-width: 90vw;
        }

        .toast {
            background: var(--bg-light);
            color: white;
            padding: 1rem 2rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            animation: slideUp 0.3s ease;
            min-width: 200px;
        }

        .toast.success {
            background: var(--accent-green);
        }

        .toast.error {
            background: var(--accent-red);
        }

        .toast.warning {
            background: var(--accent-yellow);
            color: var(--bg-dark);
        }

        .toast.info {
            background: var(--primary-blue);
        }

        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes slideDown {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(100%); opacity: 0; }
        }

        /* Offline Banner */
        .offline-banner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: var(--accent-yellow);
            color: var(--bg-dark);
            padding: 0.5rem;
            text-align: center;
            z-index: 10000;
            display: none;
            font-weight: 600;
        }

        .offline-banner.active {
            display: block;
        }

        /* Critical Error Display */
        .critical-error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--accent-red);
            color: white;
            padding: 2rem;
            border-radius: var(--border-radius);
            text-align: center;
            z-index: 30000;
            max-width: 90%;
            display: none;
        }

        .critical-error.active {
            display: block;
        }

        /* Mobile Specific */
        @media (max-width: 768px) {
            .app-container {
                padding: 0.5rem;
            }
            
            .app-header {
                padding: 1rem;
            }
            
            .app-title { 
                font-size: 1.5rem; 
            }
            
            .sync-status {
                position: static;
                margin-top: 1rem;
                justify-content: center;
            }
            
            .nav-tabs { 
                padding: 0 0.5rem; 
            }
            
            .nav-tab { 
                padding: 0.5rem 1rem; 
                font-size: 0.9rem; 
            }
            
            .map-container { 
                height: 60vh; 
                min-height: 400px; 
            }
            
            .map-controls { 
                bottom: 0.5rem; 
                right: 0.5rem; 
                gap: 0.5rem;
            }
            
            .map-overlay { 
                top: 0.5rem; 
                left: 0.5rem; 
                max-width: calc(100% - 70px);
            }

            /* Stack overlay elements vertically on mobile */
            .layer-selector {
                font-size: 0.8rem;
            }

            .tide-display {
                font-size: 0.8rem;
                padding: 0.5rem 0.75rem;
            }

            .gps-precision {
                top: auto;
                bottom: 8rem;
                right: 0.5rem;
                left: auto;
                font-size: 0.75rem;
                padding: 0.4rem 0.75rem;
                max-width: 150px;
            }

            .gps-info-panel {
                top: 1rem;
                right: 1rem;
                left: auto;
                max-width: 200px;
                font-size: 0.75rem;
                padding: 0.5rem;
            }
            
            .gps-status {
                font-size: 0.8rem;
                padding: 0.5rem 0.75rem;
                min-width: 160px;
            }
            
            .btn-icon {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }
            
            .card {
                padding: 1rem;
            }
            
            .weather-details {
                grid-template-columns: 1fr;
            }
            
            .fish-species-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
            
            .emergency-button {
                width: 50px;
                height: 50px;
                font-size: 1.25rem;
                bottom: 1rem;
                right: 1rem;
            }

            .data-status {
                grid-template-columns: 1fr;
            }

            /* Modal anpassungen f√ºr Mobile */
            .modal-content {
                margin: 0.5rem;
                max-height: 95vh;
            }

            .position-selector {
                width: 95%;
                padding: 1rem;
            }
        }

        @media (max-width: 480px) {
            .nav-tab {
                padding: 0.5rem;
                font-size: 0.8rem;
            }
            
            .nav-tab span:nth-child(2) {
                display: none;
            }
            
            .map-container {
                height: 50vh;
                min-height: 350px;
            }
            
            .weather-main {
                flex-direction: column;
            }

            .btn {
                padding: 0.5rem 1rem;
                font-size: 0.85rem;
            }

            .position-selector {
                padding: 1rem;
            }

            /* Noch kompaktere Overlay-Anordnung f√ºr kleine Screens */
            .map-overlay {
                font-size: 0.75rem;
                gap: 0.3rem;
            }

            .gps-status {
                min-width: 140px;
                font-size: 0.7rem;
                padding: 0.4rem 0.6rem;
            }

            .layer-selector {
                font-size: 0.7rem;
                padding: 0.4rem;
            }

            .layer-selector select {
                font-size: 0.7rem;
            }

            .tide-display {
                font-size: 0.7rem;
                padding: 0.4rem 0.6rem;
            }

            .gps-precision {
                font-size: 0.7rem;
                padding: 0.3rem 0.6rem;
                max-width: 130px;
            }

            .gps-info-panel {
                font-size: 0.7rem;
                padding: 0.4rem;
                max-width: 180px;
            }

            /* Emergency button anpassen */
            .emergency-button {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
                bottom: 0.5rem;
                right: 0.5rem;
            }

            /* Map controls kompakter */
            .map-controls {
                gap: 0.3rem;
            }

            .btn-icon {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }
        }

        /* Utility Classes */
        .text-center { text-align: center; }
        .text-muted { color: var(--text-muted); }
        .text-success { color: var(--accent-green); }
        .text-danger { color: var(--accent-red); }
        .text-warning { color: var(--accent-yellow); }
        .mt-1 { margin-top: 0.5rem; }
        .mt-2 { margin-top: 1rem; }
        .mb-1 { margin-bottom: 0.5rem; }
        .mb-2 { margin-bottom: 1rem; }
        .d-none { display: none !important; }
        .flex { display: flex; }
        .flex-center { display: flex; align-items: center; justify-content: center; }
        .gap-1 { gap: 0.5rem; }
        .gap-2 { gap: 1rem; }
        .hidden { display: none !important; }

        /* Custom Marker */
        .custom-marker {
            background: transparent !important;
            border: none !important;
        }

        /* Map Click Indicator */
        .map-click-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 107, 53, 0.3);
            border: 2px solid var(--accent-orange);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: clickPulse 0.5s ease-out;
            z-index: 1000;
        }

        @keyframes clickPulse {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-light);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-blue);
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                color: black;
            }
            
            .map-controls,
            .map-overlay,
            .emergency-button,
            .nav-tabs,
            .btn,
            .modal {
                display: none !important;
            }
        }

        /* iOS Specific Fixes */
        @supports (-webkit-touch-callout: none) {
            .modal-content {
                -webkit-overflow-scrolling: touch;
            }
            
            input[type="text"],
            input[type="number"],
            textarea,
            select {
                font-size: 16px !important;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Offline Banner -->
        <div class="offline-banner" id="offlineBanner">
            ‚ö†Ô∏è Offline-Modus - Einige Funktionen sind eingeschr√§nkt
        </div>

        <!-- Critical Error Display -->
        <div class="critical-error" id="criticalError">
            <h2>‚ö†Ô∏è Kritischer Fehler</h2>
            <p id="criticalErrorMessage"></p>
            <button class="btn btn-warning mt-2" onclick="location.reload()">App neu starten</button>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">Lade Anwendung...</div>
        </div>

        <!-- Header -->
        <header class="app-header">
            <h1 class="app-title">
                ‚öì Hochseeangeln Leka üåä
            </h1>
            <p class="app-subtitle">Professionelle Navigations- & Sicherheits-App</p>
            
            <div class="sync-status">
                <span class="sync-indicator" id="syncIndicator"></span>
                <span id="syncStatus">Daten gesichert</span>
            </div>

            <!-- Navigation -->
            <nav class="nav-tabs">
                <button class="nav-tab active" data-section="map">
                    <span>üó∫Ô∏è</span>
                    <span>Karte</span>
                </button>
                <button class="nav-tab" data-section="spots">
                    <span>üìç</span>
                    <span>Angelpl√§tze</span>
                    <span class="badge" id="spotsBadge" style="display: none;">0</span>
                </button>
                <button class="nav-tab" data-section="journal">
                    <span>üìñ</span>
                    <span>Fangbuch</span>
                    <span class="badge" id="catchesBadge" style="display: none;">0</span>
                </button>
                <button class="nav-tab" data-section="weather">
                    <span>üå§Ô∏è</span>
                    <span>Wetter</span>
                </button>
                <button class="nav-tab" data-section="route">
                    <span>üß≠</span>
                    <span>Route</span>
                </button>
                <button class="nav-tab" data-section="settings">
                    <span>‚öôÔ∏è</span>
                    <span>Einstellungen</span>
                </button>
            </nav>
        </header>

        <!-- Content Container -->
        <main class="content-container">
            <!-- Karten Section -->
            <section id="map-section" class="content-section active">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Interaktive Seekarte</h3>
                        <div class="flex gap-1">
                            <button class="btn btn-success" id="addMarkerBtn">
                                <span>üìå</span>
                                <span>Marker setzen</span>
                            </button>
                        </div>
                    </div>

                    <div class="map-container" id="mapContainer">
                        <!-- Leaflet Map -->
                        <div id="leafletMap" class="map-layer"></div>
                        
                        <!-- Kystinfo.no Iframe -->
                        <iframe 
                            id="kystinfoFrame" 
                            class="map-layer hidden"
                            src="https://kystinfo.no"
                            title="Kystinfo Seekarte"
                            scrolling="yes" 
                            frameborder="0"
                            sandbox="allow-same-origin allow-scripts allow-forms">
                        </iframe>

                        <!-- PDF Viewer -->
                        <div id="pdfViewer" class="map-layer hidden">
                            <canvas id="pdfCanvas"></canvas>
                            <div class="pdf-controls">
                                <button class="pdf-zoom-btn" id="pdfZoomIn" title="Vergr√∂√üern">+</button>
                                <button class="pdf-zoom-btn" id="pdfZoomOut" title="Verkleinern">‚àí</button>
                                <button class="pdf-zoom-btn" id="pdfZoomReset" title="Zur√ºcksetzen">‚ü≤</button>
                            </div>
                        </div>

                        <!-- GPS Track Overlay for non-Leaflet maps -->
                        <div class="gps-track-overlay hidden" id="gpsTrackOverlay">
                            <svg class="gps-track-svg" id="gpsTrackSvg"></svg>
                        </div>

                        <!-- Marker Overlay for non-Leaflet maps -->
                        <div class="marker-overlay hidden" id="markerOverlay"></div>

                        <!-- Map Overlay Controls -->
                        <div class="map-overlay">
                            <div class="gps-status">
                                <span class="gps-indicator" id="gpsIndicator"></span>
                                <span class="gps-status-text" id="gpsStatus">GPS bereit</span>
                            </div>
                            <div class="layer-selector">
                                <select id="mapLayerSelect">
                                    <option value="leaflet">Leaflet Seekarte</option>
                                    <option value="kystinfo">Kystinfo.no</option>
                                    <option value="pdf">Detailkarte PDF</option>
                                </select>
                            </div>
                            <div class="tide-display" id="tideDisplay">
                                <span class="tide-icon">üåä</span>
                                <div class="tide-status">
                                    <div class="tide-main" id="tideMain">Lade Gezeiten...</div>
                                    <div class="tide-next" id="tideNext"></div>
                                </div>
                            </div>
                        </div>

                        <!-- GPS Precision Indicator -->
                        <div class="gps-precision" id="gpsPrecision" style="display: none;">
                            <div>GPS-Pr√§zision: <span id="precisionValue">--</span>m</div>
                            <div class="precision-bar">
                                <div class="precision-fill" id="precisionFill" style="width: 0%;"></div>
                            </div>
                        </div>

                        <!-- GPS Info Panel -->
                        <div class="gps-info-panel" id="gpsInfoPanel">
                            <div class="gps-info-row">
                                <span class="gps-info-label">Position:</span>
                                <span class="gps-info-value" id="gpsPosition">--</span>
                            </div>
                            <div class="gps-info-row">
                                <span class="gps-info-label">Genauigkeit:</span>
                                <span class="gps-info-value" id="gpsAccuracy">--</span>
                            </div>
                            <div class="gps-info-row">
                                <span class="gps-info-label">H√∂he:</span>
                                <span class="gps-info-value" id="gpsAltitude">--</span>
                            </div>
                            <div class="gps-info-row">
                                <span class="gps-info-label">Geschw.:</span>
                                <span class="gps-info-value" id="gpsSpeed">--</span>
                            </div>
                            <div class="gps-info-row">
                                <span class="gps-info-label">Richtung:</span>
                                <span class="gps-info-value" id="gpsHeading">--</span>
                            </div>
                            <div class="gps-info-row">
                                <span class="gps-info-label">Satelliten:</span>
                                <span class="gps-info-value" id="gpsSatellites">--</span>
                            </div>
                        </div>

                        <!-- Map Controls -->
                        <div class="map-controls">
                            <button class="btn btn-icon btn-secondary" id="gpsToggle" title="GPS aktivieren">
                                <span>üìç</span>
                            </button>
                            <button class="btn btn-icon btn-secondary" id="centerMap" title="Karte zentrieren">
                                <span>üéØ</span>
                            </button>
                            <button class="btn btn-icon btn-secondary" id="trackToggle" title="Route aufzeichnen">
                                <span>„Ä∞Ô∏è</span>
                            </button>
                            <button class="btn btn-icon btn-secondary" id="gpsInfoToggle" title="GPS Details">
                                <span>üìä</span>
                            </button>
                            <button class="btn btn-icon btn-secondary" id="fullscreenMap" title="Vollbild">
                                <span>‚õ∂</span>
                            </button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Angelpl√§tze Section -->
            <section id="spots-section" class="content-section">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Gespeicherte Angelpl√§tze</h3>
                        <div class="flex gap-1">
                            <button class="btn btn-secondary" id="exportSpots">
                                <span>üíæ</span>
                                <span>Export</span>
                            </button>
                            <button class="btn btn-secondary" id="importSpots">
                                <span>üìÅ</span>
                                <span>Import</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="data-status">
                        <div class="status-item">
                            <div class="status-value" id="totalSpots">0</div>
                            <div class="status-label">Angelpl√§tze</div>
                        </div>
                        <div class="status-item">
                            <div class="status-value" id="todaySpots">0</div>
                            <div class="status-label">Heute hinzugef√ºgt</div>
                        </div>
                        <div class="status-item">
                            <div class="status-value" id="favoriteSpots">0</div>
                            <div class="status-label">Favoriten</div>
                        </div>
                    </div>
                    
                    <div id="spotsList" class="marker-list">
                        <div class="text-center text-muted">
                            <p>Noch keine Angelpl√§tze gespeichert.</p>
                            <p>F√ºgen Sie Marker √ºber die Karte hinzu!</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Fangbuch Section -->
            <section id="journal-section" class="content-section">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Fangbuch</h3>
                        <button class="btn btn-success" id="addCatch">
                            <span>üé£</span>
                            <span>Neuer Fang</span>
                        </button>
                    </div>
                    
                    <div class="data-status">
                        <div class="status-item">
                            <div class="status-value" id="totalCatches">0</div>
                            <div class="status-label">F√§nge gesamt</div>
                        </div>
                        <div class="status-item">
                            <div class="status-value" id="todayCatches">0</div>
                            <div class="status-label">Heute</div>
                        </div>
                        <div class="status-item">
                            <div class="status-value" id="totalWeight">0</div>
                            <div class="status-label">Gesamtgewicht (kg)</div>
                        </div>
                    </div>
                    
                    <div id="catchList" class="catch-list">
                        <div class="text-center text-muted">
                            <p>Noch keine F√§nge dokumentiert.</p>
                            <p>Tragen Sie Ihren ersten Fang ein!</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Wetter Section -->
            <section id="weather-section" class="content-section">
                <div class="weather-widget">
                    <div class="weather-alert" id="weatherAlert" style="display: none;">
                        ‚ö†Ô∏è STURMWARNUNG
                    </div>
                    
                    <div class="weather-main">
                        <div class="weather-current">
                            <div class="weather-icon" id="weatherIcon">‚òÄÔ∏è</div>
                            <div class="weather-temp" id="weatherTemp">--¬∞C</div>
                            <div class="weather-condition" id="weatherCondition">--</div>
                        </div>
                    </div>
                    
                    <div class="weather-details">
                        <div class="weather-detail">
                            <span class="weather-detail-icon">üí®</span>
                            <div class="weather-detail-value" id="windSpeed">-- km/h</div>
                            <div class="weather-detail-label">Wind</div>
                        </div>
                        <div class="weather-detail">
                            <span class="weather-detail-icon">üåä</span>
                            <div class="weather-detail-value" id="waveHeight">-- m</div>
                            <div class="weather-detail-label">Wellenh√∂he</div>
                        </div>
                        <div class="weather-detail">
                            <span class="weather-detail-icon">üå°Ô∏è</span>
                            <div class="weather-detail-value" id="pressure">-- hPa</div>
                            <div class="weather-detail-label">Luftdruck</div>
                        </div>
                        <div class="weather-detail">
                            <span class="weather-detail-icon">üëÅÔ∏è</span>
                            <div class="weather-detail-value" id="visibility">-- km</div>
                            <div class="weather-detail-label">Sicht</div>
                        </div>
                    </div>
                </div>

                <div class="tide-chart">
                    <h4>Gezeitenverlauf</h4>
                    <canvas class="tide-chart-canvas" id="tideChart"></canvas>
                </div>

                <div class="card mt-2">
                    <h3 class="card-title">Angelvorhersage</h3>
                    <div id="fishingForecast">
                        <div class="text-center text-muted">
                            <p>Aktivieren Sie GPS f√ºr lokale Vorhersage</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Route Section -->
            <section id="route-section" class="content-section">
                <div class="card">
                    <h3 class="card-title">Route & Navigation</h3>
                    
                    <div class="route-stats">
                        <div class="route-stat">
                            <div class="route-stat-value" id="routeDistance">0.0</div>
                            <div class="route-stat-label">Distanz (km)</div>
                        </div>
                        <div class="route-stat">
                            <div class="route-stat-value" id="routeDuration">00:00</div>
                            <div class="route-stat-label">Dauer</div>
                        </div>
                        <div class="route-stat">
                            <div class="route-stat-value" id="routeSpeed">0.0</div>
                            <div class="route-stat-label">√ò km/h</div>
                        </div>
                        <div class="route-stat">
                            <div class="route-stat-value" id="routePoints">0</div>
                            <div class="route-stat-label">Wegpunkte</div>
                        </div>
                    </div>
                    
                    <div class="flex gap-2 mt-2">
                        <button class="btn btn-success" id="startRoute">
                            <span>‚ñ∂Ô∏è</span>
                            <span>Route starten</span>
                        </button>
                        <button class="btn btn-danger" id="stopRoute" disabled>
                            <span>‚èπÔ∏è</span>
                            <span>Route beenden</span>
                        </button>
                        <button class="btn btn-secondary" id="saveRoute">
                            <span>üíæ</span>
                            <span>Route speichern</span>
                        </button>
                    </div>
                    
                    <div class="mt-2">
                        <h4>Gespeicherte Routen</h4>
                        <div id="savedRoutes" class="marker-list">
                            <div class="text-center text-muted">
                                <p>Keine gespeicherten Routen vorhanden.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Einstellungen Section -->
            <section id="settings-section" class="content-section">
                <div class="card">
                    <h3 class="card-title">Einstellungen</h3>

                    <h4 class="mb-2">üå§Ô∏è Wetter-APIs</h4>
                    
                    <div class="form-group">
                        <label class="form-label">OpenWeatherMap API Key <span class="required">*</span></label>
                        <input type="text" class="form-control" id="openWeatherApiKey" 
                               placeholder="Ihren API Key hier eingeben">
                        <small style="color: var(--text-secondary); display: block; margin-top: 0.25rem;">
                            Kostenlos registrieren auf <a href="https://openweathermap.org/api" target="_blank" style="color: var(--primary-blue-light);">openweathermap.org</a>
                        </small>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Stormglass API Key (f√ºr Wellen & Gezeiten)</label>
                        <input type="text" class="form-control" id="stormglassApiKey" 
                               placeholder="Optional - f√ºr erweiterte Meeresdaten">
                        <small style="color: var(--text-secondary); display: block; margin-top: 0.25rem;">
                            Registrieren auf <a href="https://stormglass.io" target="_blank" style="color: var(--primary-blue-light);">stormglass.io</a> (50 Anfragen/Tag kostenlos)
                        </small>
                    </div>

                    <h4 class="mb-2 mt-2">üìç Standort & Navigation</h4>
                    
                    <div class="form-group">
                        <label class="form-label">Insel Leka Koordinaten</label>
                        <div class="coords-display">
                            <input type="text" class="form-control coords-input" id="lekaCoords" 
                                   value="65.0960, 11.7000" readonly>
                            <button class="coords-copy" id="copyLekaCoords" title="Kopieren">üìã</button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">GPS-Genauigkeit</label>
                        <select class="form-control" id="gpsAccuracy">
                            <option value="high">H√∂chste Genauigkeit (empfohlen)</option>
                            <option value="medium">Mittlere Genauigkeit</option>
                            <option value="low">Niedrige Genauigkeit (energiesparend)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">GPS-Update-Intervall</label>
                        <select class="form-control" id="gpsUpdateInterval">
                            <option value="1000">1 Sekunde (h√∂chste Pr√§zision)</option>
                            <option value="3000">3 Sekunden</option>
                            <option value="5000">5 Sekunden</option>
                            <option value="10000">10 Sekunden</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Automatisches GPS beim Start</label>
                        <select class="form-control" id="autoGps">
                            <option value="true">Aktiviert (empfohlen)</option>
                            <option value="false">Deaktiviert</option>
                        </select>
                    </div>

                    <h4 class="mb-2 mt-2">üó∫Ô∏è Karten</h4>
                    
                    <div class="form-group">
                        <label class="form-label">Zus√§tzliche Karten-URLs (eine pro Zeile)</label>
                        <textarea class="form-control" id="customMapUrls" rows="3" 
                                  placeholder="https://example.com/karte1.pdf&#10;https://example.com/karte2.pdf">https://raw.githack.com/Jamancode/jamancode.github.io/main/Karten/West_best.pdf</textarea>
                    </div>

                    <h4 class="mb-2 mt-2">üíæ Datenverwaltung</h4>
                    
                    <div class="data-status">
                        <div class="status-item">
                            <div class="status-value" id="storageUsed">0</div>
                            <div class="status-label">MB genutzt</div>
                        </div>
                        <div class="status-item">
                            <div class="status-value" id="lastBackup">Nie</div>
                            <div class="status-label">Letztes Backup</div>
                        </div>
                        <div class="status-item">
                            <div class="status-value" id="dataAge">0</div>
                            <div class="status-label">Tage Daten</div>
                        </div>
                    </div>

                    <div class="flex gap-2 mt-2">
                        <button class="btn btn-success" id="saveSettings">
                            <span>üíæ</span>
                            <span>Speichern</span>
                        </button>
                        <button class="btn btn-secondary" id="backupData">
                            <span>üì¶</span>
                            <span>Backup erstellen</span>
                        </button>
                        <button class="btn btn-secondary" id="restoreData">
                            <span>üì•</span>
                            <span>Backup laden</span>
                        </button>
                        <button class="btn btn-warning" id="testAlerts">
                            <span>üîî</span>
                            <span>Test-Alarm</span>
                        </button>
                        <button class="btn btn-danger" id="clearData">
                            <span>üóëÔ∏è</span>
                            <span>Alle Daten l√∂schen</span>
                        </button>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Emergency Button -->
    <button class="emergency-button" id="emergencyButton" title="Notfall - Position senden">
        üÜò
    </button>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Position Selection Dialog -->
    <div class="position-selector" id="positionSelector">
        <h3>Marker-Position w√§hlen</h3>
        <div class="position-options">
            <div class="position-option" id="selectCurrentPosition">
                <div class="position-option-icon">üìç</div>
                <div class="position-option-text">
                    <h4>Aktuelle GPS-Position</h4>
                    <p id="currentPositionInfo">Position wird ermittelt...</p>
                </div>
            </div>
            <div class="position-option" id="selectMapPosition">
                <div class="position-option-icon">üó∫Ô∏è</div>
                <div class="position-option-text">
                    <h4>Position auf Karte w√§hlen</h4>
                    <p>Klicken Sie auf die gew√ºnschte Stelle</p>
                </div>
            </div>
            <div class="position-option" id="selectManualPosition">
                <div class="position-option-icon">‚å®Ô∏è</div>
                <div class="position-option-text">
                    <h4>Koordinaten manuell eingeben</h4>
                    <p>F√ºr pr√§zise Positionsangaben</p>
                </div>
            </div>
        </div>
        <button class="btn btn-secondary mt-2" id="cancelPositionSelect">Abbrechen</button>
    </div>

    <!-- Modals -->
    <!-- Marker Modal -->
    <div class="modal" id="markerModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">üìç Angelplatz hinzuf√ºgen</h3>
                <button class="modal-close" id="closeMarkerModal">√ó</button>
            </div>
            <div class="modal-body">
                <form id="markerForm">
                    <div class="form-group">
                        <label class="form-label">Name des Angelplatzes <span class="required">*</span></label>
                        <input type="text" class="form-control" id="markerName" required 
                               placeholder="z.B. Leka Nordspitze Tiefwasser">
                    </div>

                    <div class="form-group">
                        <label class="form-label">GPS-Koordinaten <span class="required">*</span></label>
                        <div class="coords-display">
                            <input type="text" class="form-control coords-input" id="markerCoords" 
                                   placeholder="Wird automatisch gesetzt" required>
                            <button type="button" class="coords-copy" id="updateMarkerGPS" title="GPS aktualisieren">üîÑ</button>
                        </div>
                        <div class="form-error" id="markerCoordsError" style="display: none;">
                            Ung√ºltige Koordinaten
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Wassertiefe (m)</label>
                        <input type="number" class="form-control" id="markerDepth" 
                               placeholder="z.B. 85" min="0" max="500">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Untergrund</label>
                        <select class="form-control" id="markerGround">
                            <option value="">-- Bitte w√§hlen --</option>
                            <option value="sand">Sand</option>
                            <option value="kies">Kies</option>
                            <option value="fels">Fels/Stein</option>
                            <option value="schlick">Schlick/Schlamm</option>
                            <option value="tang">Tang/Algen</option>
                            <option value="mixed">Gemischt</option>
                            <option value="riff">Riff</option>
                            <option value="wrack">Wrack</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Zielfischarten</label>
                        <div class="fish-species-grid" id="markerFishGrid">
                            <!-- Wird dynamisch gef√ºllt -->
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Str√∂mung</label>
                        <select class="form-control" id="markerCurrent">
                            <option value="">-- Bitte w√§hlen --</option>
                            <option value="keine">Keine</option>
                            <option value="schwach">Schwach</option>
                            <option value="mittel">Mittel</option>
                            <option value="stark">Stark</option>
                            <option value="sehr-stark">Sehr stark</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Beste Gezeiten</label>
                        <select class="form-control" id="markerTide">
                            <option value="">-- Bitte w√§hlen --</option>
                            <option value="egal">Egal</option>
                            <option value="flut">Auflaufend (Flut)</option>
                            <option value="hoch">Hochwasser</option>
                            <option value="ebbe">Ablaufend (Ebbe)</option>
                            <option value="niedrig">Niedrigwasser</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Notizen</label>
                        <textarea class="form-control" id="markerNotes" rows="3" 
                                  placeholder="Besondere Merkmale, beste Angelzeiten, K√∂derempfehlungen, Gefahren..."></textarea>
                    </div>

                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="markerFavorite"> Als Favorit markieren ‚≠ê
                        </label>
                    </div>

                    <div class="flex gap-2">
                        <button type="submit" class="btn btn-success">
                            <span>üíæ</span>
                            <span>Speichern</span>
                        </button>
                        <button type="button" class="btn btn-secondary" id="markerTestGPS">
                            <span>üéØ</span>
                            <span>GPS testen</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Catch Modal -->
    <div class="modal" id="catchModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">üé£ Neuen Fang eintragen</h3>
                <button class="modal-close" id="closeCatchModal">√ó</button>
            </div>
            <div class="modal-body">
                <form id="catchForm">
                    <div class="form-group">
                        <label class="form-label">Datum & Zeit <span class="required">*</span></label>
                        <input type="datetime-local" class="form-control" id="catchDateTime" required>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Fischart <span class="required">*</span></label>
                        <div class="fish-species-grid" id="catchFishGrid">
                            <!-- Wird dynamisch gef√ºllt -->
                        </div>
                        <input type="hidden" id="catchFishType" required>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Gewicht (kg)</label>
                        <input type="number" step="0.1" class="form-control" id="catchWeight" 
                               placeholder="z.B. 12.5" min="0">
                    </div>

                    <div class="form-group">
                        <label class="form-label">L√§nge (cm)</label>
                        <input type="number" class="form-control" id="catchLength" 
                               placeholder="z.B. 95" min="0">
                    </div>

                    <div class="form-group">
                        <label class="form-label">GPS-Position <span class="required">*</span></label>
                        <div class="coords-display">
                            <input type="text" class="form-control coords-input" id="catchGPS" 
                                   placeholder="Wird automatisch gesetzt" required>
                            <button type="button" class="coords-copy" id="updateCatchGPS" title="GPS aktualisieren">üîÑ</button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Angelplatz</label>
                        <select class="form-control" id="catchSpot">
                            <option value="">-- Kein spezifischer Platz --</option>
                            <!-- Wird dynamisch mit gespeicherten Spots gef√ºllt -->
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">K√∂der</label>
                        <input type="text" class="form-control" id="catchBait" 
                               placeholder="z.B. Pilker 200g Blau-Silber">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Tiefe (m)</label>
                        <input type="number" class="form-control" id="catchDepth" 
                               placeholder="z.B. 45" min="0">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Wetterbedingungen</label>
                        <div class="weather-summary" id="catchWeatherSummary">
                            <!-- Wird automatisch gef√ºllt -->
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Foto</label>
                        <input type="file" class="form-control" id="catchPhoto" accept="image/*">
                        <div id="photoPreview" style="margin-top: 0.5rem;"></div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Notizen</label>
                        <textarea class="form-control" id="catchNotes" rows="3" 
                                  placeholder="Besondere Umst√§nde, Kampf, K√∂derf√ºhrung..."></textarea>
                    </div>

                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="catchReleased"> Fisch zur√ºckgesetzt üêü
                        </label>
                    </div>

                    <div class="flex gap-2">
                        <button type="submit" class="btn btn-success">
                            <span>üíæ</span>
                            <span>Speichern</span>
                        </button>
                        <button type="button" class="btn btn-secondary" id="catchFromCurrentPosition">
                            <span>üìç</span>
                            <span>Aktuelle Position</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

            // GPS Permission Modal -->
    <div class="modal" id="gpsPermissionModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h3 class="modal-title">üìç GPS-Berechtigung erforderlich</h3>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 1rem;">
                    Diese App ben√∂tigt Zugriff auf Ihren Standort f√ºr folgende Funktionen:
                </p>
                <ul style="margin-left: 1.5rem; margin-bottom: 1rem; color: var(--text-secondary);">
                    <li>Markierung von Angelpl√§tzen</li>
                    <li>Navigation zu gespeicherten Spots</li>
                    <li>Lokale Wettervorhersage</li>
                    <li>Tracking Ihrer Route</li>
                    <li>Notfall-Positions√ºbermittlung</li>
                </ul>
                <p style="margin-bottom: 1.5rem; color: var(--text-secondary);">
                    <strong>Datenschutz:</strong> Ihre Standortdaten werden nur lokal auf Ihrem Ger√§t gespeichert 
                    und nicht an externe Server √ºbertragen.
                </p>
                <div class="flex gap-2" style="justify-content: center;">
                    <button class="btn btn-success" id="allowGPS">
                        <span>‚úì</span>
                        <span>GPS erlauben</span>
                    </button>
                    <button class="btn btn-secondary" id="denyGPS">
                        <span>‚úó</span>
                        <span>Sp√§ter</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Emergency Modal -->
    <div class="modal" id="emergencyModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header" style="background: var(--accent-red);">
                <h3 class="modal-title">üÜò NOTFALL</h3>
                <button class="modal-close" id="closeEmergencyModal">√ó</button>
            </div>
            <div class="modal-body">
                <div class="text-center">
                    <h4>Aktuelle Position</h4>
                    <div class="coords-display mt-1">
                        <input type="text" class="form-control coords-input text-center" 
                               id="emergencyCoords" readonly style="font-size: 1.2rem; font-weight: bold;">
                        <button class="coords-copy" id="copyEmergencyCoords" title="Kopieren">üìã</button>
                    </div>
                    
                    <div class="mt-2">
                        <p><strong>Notruf Norwegen:</strong></p>
                        <p style="font-size: 2rem; font-weight: bold; color: var(--accent-red);">üìû 113</p>
                        <p>Seenotrettung: <strong>120</strong></p>
                        <p>Polizei: <strong>112</strong></p>
                    </div>
                    
                    <div class="mt-2">
                        <button class="btn btn-danger" id="sendEmergencyPosition">
                            <span>üì°</span>
                            <span>Position teilen</span>
                        </button>
                    </div>
                    
                    <div class="mt-2" style="font-size: 0.9rem; color: var(--text-secondary);">
                        <p>Bleiben Sie ruhig. Hilfe ist unterwegs.</p>
                        <p>GPS wird kontinuierlich aktualisiert.</p>
                        <p id="emergencyLastUpdate">Letzte Aktualisierung: --</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" integrity="sha512-q+4liFwdPC/bNdhUpZx6aXDx/h77yEQtn4I1slHydcbZK34nLaR3cAeYSJshoxIOq3mjEf7xJE8YWIUHMn+oCQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <script>
        'use strict';

        // ====================================
        // KONFIGURATION & KONSTANTEN
        // ====================================
        const APP_CONFIG = {
            appName: 'HochseeangelnLeka',
            version: '2.0.0',
            dbName: 'HochseeangelnLekaDB',
            dbVersion: 1,
            defaultLocation: { lat: 65.0960, lng: 11.7000 }, // Leka Island
            mapZoom: 12,
            maxGPSAge: 30000, // 30 Sekunden
            routeRecordInterval: 5000, // 5 Sekunden
            autosaveInterval: 10000, // 10 Sekunden f√ºr kritische Sicherheit
            weatherUpdateInterval: 600000, // 10 Minuten
            tideUpdateInterval: 3600000, // 1 Stunde
            emergencyUpdateInterval: 5000, // 5 Sekunden im Notfall
            
            // API Endpoints
            apis: {
                openWeather: 'https://api.openweathermap.org/data/2.5',
                stormglass: 'https://api.stormglass.io/v2',
                nominatim: 'https://nominatim.openstreetmap.org'
            },
            
            // GPS Optionen
            gpsOptions: {
                high: {
                    enableHighAccuracy: true,
                    timeout: 20000,
                    maximumAge: 0
                },
                medium: {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 5000
                },
                low: {
                    enableHighAccuracy: false,
                    timeout: 10000,
                    maximumAge: 30000
                }
            }
        };

        // Fischarten-Datenbank
        const FISH_DATABASE = {
            'kabeljau': { 
                name: 'Kabeljau (Dorsch)', 
                icon: 'üêü',
                scientific: 'Gadus morhua',
                minSize: 47,
                season: 'Ganzj√§hrig, beste Zeit: Januar-April',
                depth: '20-200m',
                bait: 'Pilker, Gummifisch, Naturk√∂der'
            },
            'seelachs': { 
                name: 'Seelachs (K√∂hler)', 
                icon: 'üêü',
                scientific: 'Pollachius virens',
                minSize: 45,
                season: 'Ganzj√§hrig, beste Zeit: Mai-September',
                depth: '0-200m',
                bait: 'Pilker, Wobbler, kleine Fische'
            },
            'heilbutt': { 
                name: 'Heilbutt', 
                icon: 'üê†',
                scientific: 'Hippoglossus hippoglossus',
                minSize: 80,
                season: 'Mai-September',
                depth: '20-500m',
                bait: 'Gro√üe K√∂fis, Makrele, Hering'
            },
            'leng': { 
                name: 'Leng', 
                icon: 'üêü',
                scientific: 'Molva molva',
                minSize: 63,
                season: 'Ganzj√§hrig',
                depth: '100-400m',
                bait: 'Pilker, Naturk√∂der'
            },
            'lumb': { 
                name: 'Lumb', 
                icon: 'üêü',
                scientific: 'Brosme brosme',
                minSize: 0,
                season: 'Ganzj√§hrig',
                depth: '100-500m',
                bait: 'Pilker, Naturk√∂der'
            },
            'rotbarsch': { 
                name: 'Rotbarsch', 
                icon: 'üêü',
                scientific: 'Sebastes norvegicus',
                minSize: 32,
                season: 'Ganzj√§hrig',
                depth: '100-400m',
                bait: 'Pilker, Gummifisch'
            },
            'pollack': { 
                name: 'Pollack', 
                icon: 'üêü',
                scientific: 'Pollachius pollachius',
                minSize: 45,
                season: 'Mai-Oktober',
                depth: '0-100m',
                bait: 'Wobbler, Gummifisch, Spinner'
            },
            'schellfisch': { 
                name: 'Schellfisch', 
                icon: 'üêü',
                scientific: 'Melanogrammus aeglefinus',
                minSize: 35,
                season: 'Ganzj√§hrig',
                depth: '40-200m',
                bait: 'Naturk√∂der, kleine Pilker'
            },
            'steinbeisser': { 
                name: 'Steinbei√üer', 
                icon: 'üêü',
                scientific: 'Anarhichas lupus',
                minSize: 0,
                season: 'Oktober-April',
                depth: '20-200m',
                bait: 'Krebse, Muscheln, Naturk√∂der'
            },
            'makrele': { 
                name: 'Makrele', 
                icon: 'üêü',
                scientific: 'Scomber scombrus',
                minSize: 30,
                season: 'Mai-September',
                depth: '0-50m',
                bait: 'Paternoster, kleine Pilker, Federjigs'
            },
            'other': { 
                name: 'Andere Art', 
                icon: 'üê†',
                scientific: '',
                minSize: 0,
                season: 'Variabel',
                depth: 'Variabel',
                bait: 'Variabel'
            }
        };

        // ====================================
        // DATENBANK MANAGER
        // ====================================
        class DatabaseManager {
            constructor() {
                this.db = null;
                this.isInitialized = false;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(APP_CONFIG.dbName, APP_CONFIG.dbVersion);
                    
                    request.onerror = () => {
                        console.error('Datenbank-Fehler:', request.error);
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isInitialized = true;
                        console.log('Datenbank erfolgreich ge√∂ffnet');
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Angelpl√§tze Store
                        if (!db.objectStoreNames.contains('markers')) {
                            const markerStore = db.createObjectStore('markers', { keyPath: 'id', autoIncrement: true });
                            markerStore.createIndex('created', 'created', { unique: false });
                            markerStore.createIndex('favorite', 'favorite', { unique: false });
                        }
                        
                        // F√§nge Store
                        if (!db.objectStoreNames.contains('catches')) {
                            const catchStore = db.createObjectStore('catches', { keyPath: 'id', autoIncrement: true });
                            catchStore.createIndex('dateTime', 'dateTime', { unique: false });
                            catchStore.createIndex('fishType', 'fishType', { unique: false });
                        }
                        
                        // Routen Store
                        if (!db.objectStoreNames.contains('routes')) {
                            const routeStore = db.createObjectStore('routes', { keyPath: 'id', autoIncrement: true });
                            routeStore.createIndex('created', 'created', { unique: false });
                            routeStore.createIndex('name', 'name', { unique: false });
                        }
                        
                        // Einstellungen Store
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                        
                        // GPS-Tracks Store (f√ºr Offline-Speicherung)
                        if (!db.objectStoreNames.contains('gpsTracks')) {
                            const trackStore = db.createObjectStore('gpsTracks', { keyPath: 'id', autoIncrement: true });
                            trackStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            }

            async saveMarker(marker) {
                try {
                    const transaction = this.db.transaction(['markers'], 'readwrite');
                    const store = transaction.objectStore('markers');
                    const request = marker.id ? store.put(marker) : store.add(marker);
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Speichern des Markers:', error);
                    throw error;
                }
            }

            async getMarkers() {
                try {
                    const transaction = this.db.transaction(['markers'], 'readonly');
                    const store = transaction.objectStore('markers');
                    const request = store.getAll();
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Abrufen der Marker:', error);
                    return [];
                }
            }

            async deleteMarker(id) {
                try {
                    const transaction = this.db.transaction(['markers'], 'readwrite');
                    const store = transaction.objectStore('markers');
                    const request = store.delete(id);
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim L√∂schen des Markers:', error);
                    throw error;
                }
            }

            async saveCatch(catchData) {
                try {
                    const transaction = this.db.transaction(['catches'], 'readwrite');
                    const store = transaction.objectStore('catches');
                    const request = catchData.id ? store.put(catchData) : store.add(catchData);
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Speichern des Fangs:', error);
                    throw error;
                }
            }

            async getCatches() {
                try {
                    const transaction = this.db.transaction(['catches'], 'readonly');
                    const store = transaction.objectStore('catches');
                    const request = store.getAll();
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Abrufen der F√§nge:', error);
                    return [];
                }
            }

            async deleteCatch(id) {
                try {
                    const transaction = this.db.transaction(['catches'], 'readwrite');
                    const store = transaction.objectStore('catches');
                    const request = store.delete(id);
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim L√∂schen des Fangs:', error);
                    throw error;
                }
            }

            async saveRoute(route) {
                try {
                    const transaction = this.db.transaction(['routes'], 'readwrite');
                    const store = transaction.objectStore('routes');
                    const request = route.id ? store.put(route) : store.add(route);
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Speichern der Route:', error);
                    throw error;
                }
            }

            async deleteRoute(id) {
                try {
                    const transaction = this.db.transaction(['routes'], 'readwrite');
                    const store = transaction.objectStore('routes');
                    const request = store.delete(id);
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim L√∂schen der Route:', error);
                    throw error;
                }
            }

            async saveSetting(key, value) {
                try {
                    const transaction = this.db.transaction(['settings'], 'readwrite');
                    const store = transaction.objectStore('settings');
                    const request = store.put({ key, value, updated: new Date().toISOString() });
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Speichern der Einstellung:', error);
                    throw error;
                }
            }

            async getSetting(key) {
                try {
                    const transaction = this.db.transaction(['settings'], 'readonly');
                    const store = transaction.objectStore('settings');
                    const request = store.get(key);
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result?.value);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Abrufen der Einstellung:', error);
                    return null;
                }
            }

            async getAllSettings() {
                try {
                    const transaction = this.db.transaction(['settings'], 'readonly');
                    const store = transaction.objectStore('settings');
                    const request = store.getAll();
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => {
                            const settings = {};
                            request.result.forEach(item => {
                                settings[item.key] = item.value;
                            });
                            resolve(settings);
                        };
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Abrufen aller Einstellungen:', error);
                    return {};
                }
            }

            async saveGPSTrack(track) {
                try {
                    const transaction = this.db.transaction(['gpsTracks'], 'readwrite');
                    const store = transaction.objectStore('gpsTracks');
                    const request = store.add(track);
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Speichern des GPS-Tracks:', error);
                    throw error;
                }
            }

            async exportData() {
                try {
                    const data = {
                        version: APP_CONFIG.version,
                        exported: new Date().toISOString(),
                        markers: await this.getMarkers(),
                        catches: await this.getCatches(),
                        routes: await this.getRoutes(),
                        settings: await this.getAllSettings()
                    };
                    
                    return data;
                } catch (error) {
                    console.error('Fehler beim Exportieren der Daten:', error);
                    throw error;
                }
            }

            async getRoutes() {
                try {
                    const transaction = this.db.transaction(['routes'], 'readonly');
                    const store = transaction.objectStore('routes');
                    const request = store.getAll();
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Fehler beim Abrufen der Routen:', error);
                    return [];
                }
            }

            async clearAllData() {
                try {
                    const stores = ['markers', 'catches', 'routes', 'settings', 'gpsTracks'];
                    const transaction = this.db.transaction(stores, 'readwrite');
                    
                    stores.forEach(storeName => {
                        transaction.objectStore(storeName).clear();
                    });
                    
                    return new Promise((resolve, reject) => {
                        transaction.oncomplete = () => resolve();
                        transaction.onerror = () => reject(transaction.error);
                    });
                } catch (error) {
                    console.error('Fehler beim L√∂schen aller Daten:', error);
                    throw error;
                }
            }
        }

        // ====================================
        // GPS MANAGER - KRITISCH F√úR SICHERHEIT
        // ====================================
        class GPSManager {
            constructor() {
                this.watchId = null;
                this.currentPosition = null;
                this.lastValidPosition = null;
                this.accuracy = null;
                this.isTracking = false;
                this.trackPoints = [];
                this.callbacks = new Map();
                this.errorCount = 0;
                this.maxErrors = 5;
                this.deadReckoningEnabled = false;
                this.lastUpdate = null;
                this.satelliteInfo = { count: 0, quality: 'unknown' };
                this.hasPermission = false;
                this.permissionRequested = false; // Verhindert mehrfache Anfragen
            }

            async startTracking(options = 'high') {
                if (this.isTracking) return;
                
                if (!navigator.geolocation) {
                    throw new Error('GPS wird von diesem Ger√§t nicht unterst√ºtzt');
                }

                const gpsOptions = APP_CONFIG.gpsOptions[options] || APP_CONFIG.gpsOptions.high;
                
                // Android-spezifische Anpassungen
                if (this.isAndroid()) {
                    gpsOptions.timeout = Math.max(gpsOptions.timeout, 15000);
                    gpsOptions.maximumAge = Math.min(gpsOptions.maximumAge, 10000);
                }
                
                try {
                    // Kontinuierliches Tracking direkt starten
                    this.watchId = navigator.geolocation.watchPosition(
                        (position) => {
                            this.hasPermission = true;
                            this.updatePosition(position);
                            if (!this.isTracking) {
                                this.isTracking = true;
                                this.updateStatus('active', 'GPS aktiv');
                                console.log('GPS-Tracking gestartet');
                            }
                        },
                        (error) => this.handleError(error),
                        gpsOptions
                    );
                    
                    // Fallback-Timer f√ºr erste Position
                    setTimeout(() => {
                        if (!this.isTracking) {
                            this.updateStatus('tracking', 'GPS sucht Signal...');
                        }
                    }, 2000);
                    
                } catch (error) {
                    console.error('GPS-Tracking Fehler:', error);
                    this.hasPermission = false;
                    this.handleError(error);
                    throw error;
                }
            }

            async requestPermission() {
                // Pr√ºfe zuerst ob Geolocation verf√ºgbar ist
                if (!navigator.geolocation) {
                    this.showError('GPS wird von diesem Ger√§t nicht unterst√ºtzt');
                    return false;
                }

                // Zeige Permission Modal
                const modal = document.getElementById('gpsPermissionModal');
                if (!modal) {
                    // Fallback: Direkt Position anfragen
                    try {
                        await this.getCurrentPosition({ 
                            enableHighAccuracy: false,
                            timeout: 10000,
                            maximumAge: 0 
                        });
                        this.hasPermission = true;
                        return true;
                    } catch (error) {
                        console.error('GPS Permission Error:', error);
                        return false;
                    }
                }

                modal.classList.add('active');

                return new Promise((resolve) => {
                    const allowBtn = document.getElementById('allowGPS');
                    const denyBtn = document.getElementById('denyGPS');

                    const cleanup = () => {
                        modal.classList.remove('active');
                        allowBtn.removeEventListener('click', handleAllow);
                        denyBtn.removeEventListener('click', handleDeny);
                    };

                    const handleAllow = async () => {
                        cleanup();
                        
                        try {
                            // Versuche Position mit niedriger Genauigkeit zuerst
                            await this.getCurrentPosition({ 
                                enableHighAccuracy: false,
                                timeout: 10000,
                                maximumAge: 0 
                            });
                            this.hasPermission = true;
                            resolve(true);
                        } catch (error) {
                            console.error('GPS permission denied or error:', error);
                            
                            // Zeige spezifischen Fehler
                            if (error.code === 1) {
                                app.showToast('GPS-Berechtigung verweigert. Bitte in den Browsereinstellungen erlauben.', 'error');
                            } else if (error.code === 2) {
                                app.showToast('GPS nicht verf√ºgbar. Bitte Standortdienste aktivieren.', 'error');
                            } else if (error.code === 3) {
                                app.showToast('GPS-Timeout. Bitte erneut versuchen.', 'error');
                            }
                            
                            this.hasPermission = false;
                            resolve(false);
                        }
                    };

                    const handleDeny = () => {
                        cleanup();
                        this.hasPermission = false;
                        app.showToast('GPS-Berechtigung verweigert. Einige Funktionen sind eingeschr√§nkt.', 'warning');
                        resolve(false);
                    };

                    allowBtn.addEventListener('click', handleAllow);
                    denyBtn.addEventListener('click', handleDeny);
                });
            }

            showError(message) {
                console.error('GPS Error:', message);
                this.updateStatus('error', message);
                
                if (window.app && window.app.showToast) {
                    window.app.showToast(message, 'error');
                }
            }

            getCurrentPosition(options) {
                return new Promise((resolve, reject) => {
                    // Timeout f√ºr bessere Fehlerbehandlung
                    const timeoutId = setTimeout(() => {
                        reject(new Error('GPS-Timeout'));
                    }, options.timeout || 10000);

                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            clearTimeout(timeoutId);
                            resolve(position);
                        },
                        (error) => {
                            clearTimeout(timeoutId);
                            reject(error);
                        },
                        options
                    );
                });
            }

            updatePosition(position) {
                this.errorCount = 0;
                this.lastUpdate = new Date();
                
                const coords = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    altitudeAccuracy: position.coords.altitudeAccuracy,
                    heading: position.coords.heading,
                    speed: position.coords.speed,
                    timestamp: position.timestamp
                };
                
                // Validierung
                if (this.validatePosition(coords)) {
                    this.currentPosition = coords;
                    this.lastValidPosition = coords;
                    this.accuracy = coords.accuracy;
                    
                    // Track-Punkte f√ºr Route speichern
                    if (this.isTracking) {
                        this.trackPoints.push({
                            ...coords,
                            time: new Date().toISOString()
                        });
                    }
                    
                    // Satelliten-Info sch√§tzen basierend auf Genauigkeit
                    this.estimateSatelliteInfo(coords.accuracy);
                    
                    // Callbacks ausf√ºhren
                    this.callbacks.forEach(callback => {
                        try {
                            callback(coords);
                        } catch (error) {
                            console.error('Fehler in GPS-Callback:', error);
                        }
                    });
                    
                    this.updateUI(coords);
                } else {
                    console.warn('Ung√ºltige GPS-Position verworfen:', coords);
                }
            }

            validatePosition(coords) {
                // Grundlegende Validierung
                if (!coords || typeof coords.lat !== 'number' || typeof coords.lng !== 'number') {
                    return false;
                }
                
                // Bereich f√ºr Norwegen/Leka pr√ºfen
                if (coords.lat < 60 || coords.lat > 72 || coords.lng < 4 || coords.lng > 32) {
                    console.warn('Position au√üerhalb Norwegens:', coords);
                    return false;
                }
                
                // Genauigkeit pr√ºfen
                if (coords.accuracy > 1000) {
                    console.warn('GPS-Genauigkeit zu niedrig:', coords.accuracy);
                    return false;
                }
                
                return true;
            }

            estimateSatelliteInfo(accuracy) {
                if (accuracy < 5) {
                    this.satelliteInfo = { count: '12+', quality: 'Exzellent' };
                } else if (accuracy < 10) {
                    this.satelliteInfo = { count: '8-11', quality: 'Sehr gut' };
                } else if (accuracy < 25) {
                    this.satelliteInfo = { count: '5-7', quality: 'Gut' };
                } else if (accuracy < 50) {
                    this.satelliteInfo = { count: '4-5', quality: 'Mittel' };
                } else {
                    this.satelliteInfo = { count: '3-4', quality: 'Schwach' };
                }
            }

            handleError(error) {
                this.errorCount++;
                console.error('GPS-Fehler:', error);
                
                let message = 'GPS-Fehler';
                
                // GeolocationPositionError codes
                if (error.code !== undefined) {
                    switch (error.code) {
                        case 1: // PERMISSION_DENIED
                            message = 'GPS-Berechtigung verweigert';
                            break;
                        case 2: // POSITION_UNAVAILABLE
                            message = 'Position nicht verf√ºgbar';
                            break;
                        case 3: // TIMEOUT
                            message = 'GPS-Timeout';
                            break;
                    }
                } else if (error.message) {
                    message = error.message;
                }
                
                this.updateStatus('error', message);
                
                // Zeige Toast-Nachricht
                if (window.app && window.app.showToast) {
                    window.app.showToast(message, 'error');
                }
                
                // Dead Reckoning bei wiederholten Fehlern
                if (this.errorCount >= this.maxErrors && this.lastValidPosition) {
                    this.enableDeadReckoning();
                }
                
                // Callbacks mit Fehler informieren
                this.callbacks.forEach(callback => {
                    if (callback.onError) {
                        callback.onError(error);
                    }
                });
            }

            enableDeadReckoning() {
                if (!this.deadReckoningEnabled && this.lastValidPosition) {
                    this.deadReckoningEnabled = true;
                    console.warn('Dead Reckoning aktiviert - Verwende letzte bekannte Position');
                    
                    if (window.app && window.app.showToast) {
                        window.app.showToast('GPS-Signal schwach - Verwende letzte Position', 'warning');
                    }
                    
                    // Gesch√§tzte Position basierend auf letzter Bewegung
                    if (this.lastValidPosition.speed && this.lastValidPosition.heading) {
                        this.estimatePosition();
                    }
                }
            }

            estimatePosition() {
                if (!this.lastValidPosition || !this.lastUpdate) return;
                
                const timeDelta = (Date.now() - this.lastUpdate) / 1000; // Sekunden
                const speed = this.lastValidPosition.speed || 0; // m/s
                const heading = this.lastValidPosition.heading || 0; // Grad
                
                // Neue Position sch√§tzen
                const distance = speed * timeDelta;
                const headingRad = heading * Math.PI / 180;
                
                const lat = this.lastValidPosition.lat + (distance * Math.cos(headingRad)) / 111111;
                const lng = this.lastValidPosition.lng + (distance * Math.sin(headingRad)) / (111111 * Math.cos(this.lastValidPosition.lat * Math.PI / 180));
                
                const estimatedPosition = {
                    ...this.lastValidPosition,
                    lat,
                    lng,
                    accuracy: this.lastValidPosition.accuracy + (timeDelta * 10), // Genauigkeit verschlechtert sich
                    estimated: true
                };
                
                // Simuliere Position-Update
                const mockPosition = {
                    coords: {
                        latitude: estimatedPosition.lat,
                        longitude: estimatedPosition.lng,
                        accuracy: estimatedPosition.accuracy,
                        altitude: estimatedPosition.altitude,
                        altitudeAccuracy: estimatedPosition.altitudeAccuracy,
                        heading: estimatedPosition.heading,
                        speed: estimatedPosition.speed
                    },
                    timestamp: Date.now()
                };
                
                this.updatePosition(mockPosition);
            }

            stopTracking() {
                if (this.watchId) {
                    navigator.geolocation.clearWatch(this.watchId);
                    this.watchId = null;
                }
                
                this.isTracking = false;
                this.deadReckoningEnabled = false;
                this.updateStatus('inactive', 'GPS inaktiv');
                
                // GPS-Precision ausblenden
                const precisionContainer = document.getElementById('gpsPrecision');
                if (precisionContainer) {
                    precisionContainer.style.display = 'none';
                }
                
                console.log('GPS-Tracking gestoppt');
            }

            onPositionUpdate(callback, id = null) {
                const callbackId = id || Date.now().toString();
                this.callbacks.set(callbackId, callback);
                return callbackId;
            }

            removeCallback(id) {
                this.callbacks.delete(id);
            }

            updateStatus(status, message) {
                const indicator = document.getElementById('gpsIndicator');
                const statusText = document.getElementById('gpsStatus');
                
                if (indicator) {
                    indicator.className = `gps-indicator ${status}`;
                }
                
                if (statusText) {
                    statusText.textContent = message;
                }
            }

            updateUI(coords) {
                // GPS-Position anzeigen
                const positionEl = document.getElementById('gpsPosition');
                if (positionEl) {
                    positionEl.textContent = `${coords.lat.toFixed(6)}, ${coords.lng.toFixed(6)}`;
                }
                
                // Genauigkeit
                const accuracyEl = document.getElementById('gpsAccuracy');
                const precisionValue = document.getElementById('precisionValue');
                const precisionFill = document.getElementById('precisionFill');
                const precisionContainer = document.getElementById('gpsPrecision');
                
                if (accuracyEl) {
                    accuracyEl.textContent = `¬±${coords.accuracy.toFixed(1)}m`;
                }
                
                if (precisionValue) {
                    precisionValue.textContent = coords.accuracy.toFixed(1);
                }
                
                if (precisionFill) {
                    const percentage = Math.max(0, Math.min(100, 100 - (coords.accuracy / 50 * 100)));
                    precisionFill.style.width = `${percentage}%`;
                }

                // Zeige Precision-Anzeige nur wenn GPS aktiv ist
                if (precisionContainer && this.isTracking) {
                    precisionContainer.style.display = 'block';
                }
                
                // Weitere GPS-Infos
                if (coords.altitude !== null) {
                    const altitudeEl = document.getElementById('gpsAltitude');
                    if (altitudeEl) {
                        altitudeEl.textContent = `${coords.altitude.toFixed(1)}m`;
                    }
                }
                
                if (coords.speed !== null) {
                    const speedEl = document.getElementById('gpsSpeed');
                    if (speedEl) {
                        const speedKmh = (coords.speed * 3.6).toFixed(1);
                        speedEl.textContent = `${speedKmh} km/h`;
                    }
                }
                
                if (coords.heading !== null) {
                    const headingEl = document.getElementById('gpsHeading');
                    if (headingEl) {
                        headingEl.textContent = `${coords.heading.toFixed(0)}¬∞`;
                    }
                }
                
                // Satelliten-Info
                const satellitesEl = document.getElementById('gpsSatellites');
                if (satellitesEl) {
                    satellitesEl.textContent = this.satelliteInfo.count;
                }
            }

            getTrackDistance() {
                if (this.trackPoints.length < 2) return 0;
                
                let distance = 0;
                for (let i = 1; i < this.trackPoints.length; i++) {
                    distance += this.calculateDistance(
                        this.trackPoints[i - 1],
                        this.trackPoints[i]
                    );
                }
                
                return distance;
            }

            calculateDistance(pos1, pos2) {
                const R = 6371e3; // Erdradius in Metern
                const œÜ1 = pos1.lat * Math.PI / 180;
                const œÜ2 = pos2.lat * Math.PI / 180;
                const ŒîœÜ = (pos2.lat - pos1.lat) * Math.PI / 180;
                const ŒîŒª = (pos2.lng - pos1.lng) * Math.PI / 180;
                
                const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                        Math.cos(œÜ1) * Math.cos(œÜ2) *
                        Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                
                return R * c;
            }

            clearTrack() {
                this.trackPoints = [];
            }

            exportTrack() {
                return {
                    points: this.trackPoints,
                    distance: this.getTrackDistance(),
                    duration: this.trackPoints.length > 0 ? 
                        new Date(this.trackPoints[this.trackPoints.length - 1].time) - new Date(this.trackPoints[0].time) : 0
                };
            }
        }

        // ====================================
        // WEATHER MANAGER
        // ====================================
        class WeatherManager {
            constructor() {
                this.currentWeather = null;
                this.forecast = null;
                this.tideData = null;
                this.lastUpdate = null;
                this.apiKeys = {
                    openWeather: null,
                    stormglass: null
                };
            }

            async init() {
                // API-Keys aus Einstellungen laden
                this.apiKeys.openWeather = await app.db.getSetting('openWeatherApiKey');
                this.apiKeys.stormglass = await app.db.getSetting('stormglassApiKey');
                
                if (!this.apiKeys.openWeather) {
                    console.warn('OpenWeatherMap API Key nicht konfiguriert');
                }
            }

            async updateWeather(lat, lng) {
                if (!this.apiKeys.openWeather) {
                    throw new Error('Wetter-API nicht konfiguriert');
                }
                
                try {
                    // Aktuelles Wetter
                    const weatherUrl = `${APP_CONFIG.apis.openWeather}/weather?lat=${lat}&lon=${lng}&appid=${this.apiKeys.openWeather}&units=metric&lang=de`;
                    const weatherResponse = await fetch(weatherUrl);
                    
                    if (!weatherResponse.ok) {
                        throw new Error('Wetterdaten konnten nicht abgerufen werden');
                    }
                    
                    this.currentWeather = await weatherResponse.json();
                    this.lastUpdate = new Date();
                    
                    // Marine-Daten von Stormglass (falls verf√ºgbar)
                    if (this.apiKeys.stormglass) {
                        await this.updateMarineData(lat, lng);
                    }
                    
                    this.updateWeatherUI();
                    
                    // Warnungen pr√ºfen
                    this.checkWeatherWarnings();
                    
                    return this.currentWeather;
                    
                } catch (error) {
                    console.error('Fehler beim Abrufen der Wetterdaten:', error);
                    
                    // Fallback auf gespeicherte Daten
                    const cached = await this.getCachedWeather();
                    if (cached) {
                        this.currentWeather = cached;
                        this.updateWeatherUI();
                        app.showToast('Offline: Verwende gespeicherte Wetterdaten', 'warning');
                    }
                    
                    throw error;
                }
            }

            async updateMarineData(lat, lng) {
                if (!this.apiKeys.stormglass) return;
                
                try {
                    const params = 'waveHeight,wavePeriod,waveDirection,windSpeed,windDirection,waterTemperature,visibility';
                    const headers = {
                        'Authorization': this.apiKeys.stormglass
                    };
                    
                    const response = await fetch(
                        `${APP_CONFIG.apis.stormglass}/weather/point?lat=${lat}&lng=${lng}&params=${params}`,
                        { headers }
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.marineData = data.hours[0]; // Aktuelle Stunde
                    }
                } catch (error) {
                    console.error('Fehler bei Stormglass API:', error);
                }
            }

            async getTideData(lat, lng) {
                if (!this.apiKeys.stormglass) {
                    // Fallback: Vereinfachte Gezeitenberechnung
                    return this.calculateSimpleTides();
                }
                
                try {
                    const headers = {
                        'Authorization': this.apiKeys.stormglass
                    };
                    
                    const response = await fetch(
                        `${APP_CONFIG.apis.stormglass}/tide/extremes/point?lat=${lat}&lng=${lng}`,
                        { headers }
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.tideData = data.data;
                        this.updateTideUI();
                        return this.tideData;
                    }
                } catch (error) {
                    console.error('Fehler beim Abrufen der Gezeitendaten:', error);
                }
                
                return this.calculateSimpleTides();
            }

            calculateSimpleTides() {
                // Vereinfachte Gezeitenberechnung als Fallback
                const now = new Date();
                const tides = [];
                
                // Generiere 4 Gezeiten pro Tag (2 Hoch, 2 Niedrig)
                for (let i = 0; i < 4; i++) {
                    const time = new Date(now);
                    time.setHours(i * 6 + Math.floor(i / 2) * 0.5);
                    
                    tides.push({
                        time: time.toISOString(),
                        height: i % 2 === 0 ? 2.5 : 0.5,
                        type: i % 2 === 0 ? 'high' : 'low'
                    });
                }
                
                return tides;
            }

            updateWeatherUI() {
                if (!this.currentWeather) return;
                
                const weather = this.currentWeather;
                
                // Temperatur
                const tempEl = document.getElementById('weatherTemp');
                if (tempEl) {
                    tempEl.textContent = `${Math.round(weather.main.temp)}¬∞C`;
                }
                
                // Bedingungen
                const conditionEl = document.getElementById('weatherCondition');
                if (conditionEl) {
                    conditionEl.textContent = weather.weather[0].description;
                }
                
                // Icon
                const iconEl = document.getElementById('weatherIcon');
                if (iconEl) {
                    iconEl.textContent = this.getWeatherEmoji(weather.weather[0].id);
                }
                
                // Wind
                const windEl = document.getElementById('windSpeed');
                if (windEl) {
                    const windSpeed = Math.round(weather.wind.speed * 3.6); // m/s zu km/h
                    windEl.textContent = `${windSpeed} km/h`;
                }
                
                // Wellenh√∂he (falls verf√ºgbar)
                const waveEl = document.getElementById('waveHeight');
                if (waveEl) {
                    if (this.marineData && this.marineData.waveHeight) {
                        waveEl.textContent = `${this.marineData.waveHeight.value.toFixed(1)} m`;
                    } else {
                        // Sch√§tzung basierend auf Windgeschwindigkeit
                        const estimatedWave = this.estimateWaveHeight(weather.wind.speed);
                        waveEl.textContent = `~${estimatedWave} m`;
                    }
                }
                
                // Luftdruck
                const pressureEl = document.getElementById('pressure');
                if (pressureEl) {
                    pressureEl.textContent = `${weather.main.pressure} hPa`;
                }
                
                // Sicht
                const visibilityEl = document.getElementById('visibility');
                if (visibilityEl) {
                    const visibility = weather.visibility / 1000; // Meter zu Kilometer
                    visibilityEl.textContent = `${visibility.toFixed(1)} km`;
                }
            }

            updateTideUI() {
                const tideMain = document.getElementById('tideMain');
                const tideNext = document.getElementById('tideNext');
                
                if (!tideMain || !this.tideData) return;
                
                const now = new Date();
                const nextTide = this.tideData.find(tide => new Date(tide.time) > now);
                
                if (nextTide) {
                    const timeUntil = new Date(nextTide.time) - now;
                    const hoursUntil = Math.floor(timeUntil / 3600000);
                    const minutesUntil = Math.floor((timeUntil % 3600000) / 60000);
                    
                    tideMain.textContent = nextTide.type === 'high' ? 'Flut' : 'Ebbe';
                    tideNext.textContent = `in ${hoursUntil}h ${minutesUntil}min`;
                }
            }

            getWeatherEmoji(code) {
                // Wetter-Icons basierend auf OpenWeatherMap codes
                if (code >= 200 && code < 300) return '‚õàÔ∏è'; // Gewitter
                if (code >= 300 && code < 400) return 'üå¶Ô∏è'; // Nieselregen
                if (code >= 500 && code < 600) return 'üåßÔ∏è'; // Regen
                if (code >= 600 && code < 700) return '‚ùÑÔ∏è'; // Schnee
                if (code >= 700 && code < 800) return 'üå´Ô∏è'; // Nebel
                if (code === 800) return '‚òÄÔ∏è'; // Klar
                if (code === 801) return 'üå§Ô∏è'; // Teilweise bew√∂lkt
                if (code === 802) return '‚õÖ'; // Bew√∂lkt
                if (code >= 803) return '‚òÅÔ∏è'; // Stark bew√∂lkt
                return 'üå°Ô∏è';
            }

            estimateWaveHeight(windSpeed) {
                // Vereinfachte Wellenh√∂hen-Sch√§tzung basierend auf Windgeschwindigkeit
                const windKmh = windSpeed * 3.6;
                
                if (windKmh < 10) return 0.5;
                if (windKmh < 20) return 1.0;
                if (windKmh < 30) return 2.0;
                if (windKmh < 40) return 3.0;
                if (windKmh < 50) return 4.0;
                return 5.0;
            }

            checkWeatherWarnings() {
                if (!this.currentWeather) return;
                
                const warnings = [];
                const wind = this.currentWeather.wind.speed * 3.6; // km/h
                
                // Wind-Warnung
                if (wind > 50) {
                    warnings.push('STURMWARNUNG');
                } else if (wind > 40) {
                    warnings.push('Starker Wind');
                }
                
                // Sicht-Warnung
                if (this.currentWeather.visibility < 1000) {
                    warnings.push('Schlechte Sicht');
                }
                
                // Gewitter
                const weatherId = this.currentWeather.weather[0].id;
                if (weatherId >= 200 && weatherId < 300) {
                    warnings.push('Gewitter');
                }
                
                // Warnungen anzeigen
                const alertEl = document.getElementById('weatherAlert');
                if (alertEl && warnings.length > 0) {
                    alertEl.textContent = `‚ö†Ô∏è ${warnings.join(', ')}`;
                    alertEl.style.display = 'block';
                    
                    // Akustischer Alarm bei Sturm
                    if (wind > 50) {
                        this.playWarningSound();
                    }
                } else if (alertEl) {
                    alertEl.style.display = 'none';
                }
            }

            playWarningSound() {
                // Einfacher Warn-Ton
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
            }

            async getCachedWeather() {
                // Implementierung f√ºr Offline-Cache
                const cached = localStorage.getItem('cached_weather');
                if (cached) {
                    const data = JSON.parse(cached);
                    // Pr√ºfe ob Daten nicht √§lter als 1 Tag
                    if (new Date() - new Date(data.timestamp) < 86400000) {
                        return data.weather;
                    }
                }
                return null;
            }

            async cacheWeather() {
                if (this.currentWeather) {
                    localStorage.setItem('cached_weather', JSON.stringify({
                        weather: this.currentWeather,
                        timestamp: new Date().toISOString()
                    }));
                }
            }

            getFishingForecast() {
                if (!this.currentWeather) return null;
                
                // Vereinfachte Fisch-Vorhersage basierend auf Wetterdaten
                const pressure = this.currentWeather.main.pressure;
                const windSpeed = this.currentWeather.wind.speed * 3.6;
                const cloudiness = this.currentWeather.clouds.all;
                
                let score = 50; // Basis-Score
                
                // Luftdruck (optimal: 1013-1020 hPa)
                if (pressure >= 1013 && pressure <= 1020) {
                    score += 20;
                } else if (pressure < 1005 || pressure > 1025) {
                    score -= 20;
                }
                
                // Wind (optimal: 5-15 km/h)
                if (windSpeed >= 5 && windSpeed <= 15) {
                    score += 15;
                } else if (windSpeed > 30) {
                    score -= 30;
                }
                
                // Bew√∂lkung (optimal: 40-70%)
                if (cloudiness >= 40 && cloudiness <= 70) {
                    score += 15;
                }
                
                // Tageszeit ber√ºcksichtigen
                const hour = new Date().getHours();
                if ((hour >= 5 && hour <= 8) || (hour >= 18 && hour <= 21)) {
                    score += 10; // D√§mmerung
                }
                
                return {
                    score: Math.max(0, Math.min(100, score)),
                    factors: {
                        pressure: pressure,
                        wind: windSpeed,
                        clouds: cloudiness
                    }
                };
            }
        }

        // ====================================
        // ROUTE MANAGER
        // ====================================
        class RouteManager {
            constructor() {
                this.isRecording = false;
                this.currentRoute = null;
                this.startTime = null;
                this.recordInterval = null;
            }

            startRecording() {
                if (this.isRecording) return;
                
                this.isRecording = true;
                this.startTime = new Date();
                this.currentRoute = {
                    name: `Route ${this.startTime.toLocaleString('de-DE')}`,
                    points: [],
                    startTime: this.startTime.toISOString(),
                    distance: 0,
                    maxSpeed: 0,
                    avgSpeed: 0
                };
                
                // UI aktualisieren
                document.getElementById('startRoute').disabled = true;
                document.getElementById('stopRoute').disabled = false;
                
                // Aufzeichnung starten
                this.recordInterval = setInterval(() => {
                    this.recordPosition();
                }, APP_CONFIG.routeRecordInterval);
                
                app.showToast('Routenaufzeichnung gestartet', 'success');
            }

            recordPosition() {
                const position = app.gps.currentPosition;
                if (!position) return;
                
                const point = {
                    lat: position.lat,
                    lng: position.lng,
                    time: new Date().toISOString(),
                    speed: position.speed || 0,
                    heading: position.heading || 0,
                    accuracy: position.accuracy
                };
                
                this.currentRoute.points.push(point);
                
                // Statistiken aktualisieren
                if (this.currentRoute.points.length > 1) {
                    const lastPoint = this.currentRoute.points[this.currentRoute.points.length - 2];
                    const distance = app.gps.calculateDistance(lastPoint, point);
                    this.currentRoute.distance += distance;
                    
                    if (point.speed > this.currentRoute.maxSpeed) {
                        this.currentRoute.maxSpeed = point.speed;
                    }
                }
                
                this.updateRouteUI();
            }

            stopRecording() {
                if (!this.isRecording) return;
                
                this.isRecording = false;
                clearInterval(this.recordInterval);
                
                this.currentRoute.endTime = new Date().toISOString();
                this.currentRoute.duration = new Date() - new Date(this.currentRoute.startTime);
                
                // Durchschnittsgeschwindigkeit berechnen
                if (this.currentRoute.distance > 0 && this.currentRoute.duration > 0) {
                    this.currentRoute.avgSpeed = (this.currentRoute.distance / 1000) / (this.currentRoute.duration / 3600000);
                }
                
                // UI aktualisieren
                document.getElementById('startRoute').disabled = false;
                document.getElementById('stopRoute').disabled = true;
                
                app.showToast('Routenaufzeichnung beendet', 'info');
                
                // Automatisch speichern Dialog anzeigen
                if (this.currentRoute.points.length > 0) {
                    this.promptSaveRoute();
                }
            }

            promptSaveRoute() {
                if (confirm('M√∂chten Sie die aufgezeichnete Route speichern?')) {
                    this.saveRoute();
                }
            }

            async saveRoute(name = null) {
                if (!this.currentRoute) return;
                
                if (name) {
                    this.currentRoute.name = name;
                }
                
                try {
                    const id = await app.db.saveRoute(this.currentRoute);
                    app.showToast('Route gespeichert', 'success');
                    
                    // Route auf Karte anzeigen
                    this.displayRoute(this.currentRoute);
                    
                    // Liste aktualisieren
                    this.loadSavedRoutes();
                    
                } catch (error) {
                    console.error('Fehler beim Speichern der Route:', error);
                    app.showToast('Fehler beim Speichern', 'error');
                }
            }

            updateRouteUI() {
                if (!this.currentRoute) return;
                
                // Distanz
                const distanceEl = document.getElementById('routeDistance');
                if (distanceEl) {
                    distanceEl.textContent = (this.currentRoute.distance / 1000).toFixed(2);
                }
                
                // Dauer
                const durationEl = document.getElementById('routeDuration');
                if (durationEl) {
                    const duration = new Date() - new Date(this.currentRoute.startTime);
                    const hours = Math.floor(duration / 3600000);
                    const minutes = Math.floor((duration % 3600000) / 60000);
                    durationEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                }
                
                // Geschwindigkeit
                const speedEl = document.getElementById('routeSpeed');
                if (speedEl && this.currentRoute.distance > 0) {
                    const avgSpeed = (this.currentRoute.distance / 1000) / ((new Date() - new Date(this.currentRoute.startTime)) / 3600000);
                    speedEl.textContent = avgSpeed.toFixed(1);
                }
                
                // Wegpunkte
                const pointsEl = document.getElementById('routePoints');
                if (pointsEl) {
                    pointsEl.textContent = this.currentRoute.points.length;
                }
            }

            displayRoute(route) {
                if (!app.map || !route.points || route.points.length === 0) return;
                
                // Entferne alte Route
                if (this.routePolyline) {
                    app.map.leafletMap.removeLayer(this.routePolyline);
                }
                
                // Konvertiere Punkte f√ºr Leaflet
                const latLngs = route.points.map(point => [point.lat, point.lng]);
                
                // Erstelle Polyline
                this.routePolyline = L.polyline(latLngs, {
                    color: '#ff6b35',
                    weight: 4,
                    opacity: 0.8
                }).addTo(app.map.leafletMap);
                
                // Zeige gesamte Route
                app.map.leafletMap.fitBounds(this.routePolyline.getBounds());
            }

            async loadSavedRoutes() {
                try {
                    const routes = await app.db.getRoutes();
                    const container = document.getElementById('savedRoutes');
                    
                    if (!container) return;
                    
                    if (routes.length === 0) {
                        container.innerHTML = '<div class="text-center text-muted"><p>Keine gespeicherten Routen vorhanden.</p></div>';
                        return;
                    }
                    
                    container.innerHTML = '';
                    
                    routes.forEach(route => {
                        const routeEl = document.createElement('div');
                        routeEl.className = 'marker-item';
                        
                        const duration = route.duration ? 
                            `${Math.floor(route.duration / 3600000)}h ${Math.floor((route.duration % 3600000) / 60000)}min` : 
                            'Unbekannt';
                        
                        routeEl.innerHTML = `
                            <div class="item-header">
                                <span class="item-title">${route.name}</span>
                                <span class="text-muted">${new Date(route.startTime).toLocaleDateString('de-DE')}</span>
                            </div>
                            <div class="item-meta">
                                <p>Distanz: ${(route.distance / 1000).toFixed(2)} km</p>
                                <p>Dauer: ${duration}</p>
                                <p>Punkte: ${route.points.length}</p>
                            </div>
                            <div class="item-actions">
                                <button class="btn btn-small btn-secondary" onclick="app.route.displayRoute(${JSON.stringify(route).replace(/"/g, '&quot;')})">
                                    <span>üó∫Ô∏è</span> Anzeigen
                                </button>
                                <button class="btn btn-small btn-secondary" onclick="app.route.exportRoute(${route.id})">
                                    <span>üíæ</span> Export
                                </button>
                                <button class="btn btn-small btn-danger" onclick="app.route.deleteRoute(${route.id})">
                                    <span>üóëÔ∏è</span>
                                </button>
                            </div>
                        `;
                        
                        container.appendChild(routeEl);
                    });
                } catch (error) {
                    console.error('Fehler beim Laden der Routen:', error);
                }
            }

            async exportRoute(id) {
                try {
                    const routes = await app.db.getRoutes();
                    const route = routes.find(r => r.id === id);
                    
                    if (!route) return;
                    
                    // GPX-Format erstellen
                    const gpx = this.createGPX(route);
                    
                    // Download
                    const blob = new Blob([gpx], { type: 'application/gpx+xml' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${route.name.replace(/[^a-z0-9]/gi, '_')}.gpx`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    app.showToast('Route exportiert', 'success');
                } catch (error) {
                    console.error('Fehler beim Exportieren:', error);
                    app.showToast('Export fehlgeschlagen', 'error');
                }
            }

            createGPX(route) {
                const gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Hochseeangeln Leka App">
  <metadata>
    <name>${route.name}</name>
    <time>${route.startTime}</time>
  </metadata>
  <trk>
    <name>${route.name}</name>
    <trkseg>
      ${route.points.map(point => `
      <trkpt lat="${point.lat}" lon="${point.lng}">
        <time>${point.time}</time>
        ${point.speed ? `<speed>${point.speed}</speed>` : ''}
        ${point.heading ? `<course>${point.heading}</course>` : ''}
      </trkpt>`).join('')}
    </trkseg>
  </trk>
</gpx>`;
                return gpx;
            }

            async deleteRoute(id) {
                if (!confirm('Route wirklich l√∂schen?')) return;
                
                try {
                    await app.db.deleteRoute(id);
                    app.showToast('Route gel√∂scht', 'info');
                    this.loadSavedRoutes();
                } catch (error) {
                    console.error('Fehler beim L√∂schen:', error);
                    app.showToast('L√∂schen fehlgeschlagen', 'error');
                }
            }
        }

        // ====================================
        // MAP MANAGER
        // ====================================
        class MapManager {
            constructor() {
                this.leafletMap = null;
                this.currentLayer = 'leaflet';
                this.markers = [];
                this.userMarker = null;
                this.trackPolyline = null;
                this.pdfDoc = null;
                this.pdfPage = null;
                this.pdfScale = 1;
                this.pdfOffset = { x: 0, y: 0 };
            }

            async init() {
                // Leaflet Map initialisieren
                this.leafletMap = L.map('leafletMap', {
                    center: [APP_CONFIG.defaultLocation.lat, APP_CONFIG.defaultLocation.lng],
                    zoom: APP_CONFIG.mapZoom,
                    zoomControl: false
                });

                // Tile Layer hinzuf√ºgen
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(this.leafletMap);

                // Zoom Controls
                L.control.zoom({
                    position: 'topright'
                }).addTo(this.leafletMap);

                // Scale
                L.control.scale({
                    position: 'bottomleft',
                    metric: true,
                    imperial: false
                }).addTo(this.leafletMap);

                // Event Handlers
                this.setupMapEvents();
                
                // PDF.js konfigurieren
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }

            setupMapEvents() {
                // Layer-Wechsel
                document.getElementById('mapLayerSelect').addEventListener('change', (e) => {
                    this.switchLayer(e.target.value);
                });

                // PDF Zoom Controls
                document.getElementById('pdfZoomIn').addEventListener('click', () => this.zoomPDF(1.2));
                document.getElementById('pdfZoomOut').addEventListener('click', () => this.zoomPDF(0.8));
                document.getElementById('pdfZoomReset').addEventListener('click', () => this.resetPDFZoom());

                // PDF Pan
                this.setupPDFPan();
            }

            async switchLayer(layerType) {
                this.currentLayer = layerType;

                // Alle Layer verstecken
                document.querySelectorAll('.map-layer').forEach(layer => {
                    layer.classList.add('hidden');
                });

                // Overlays verstecken/zeigen
                const overlays = ['gpsTrackOverlay', 'markerOverlay'];
                overlays.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.classList.toggle('hidden', layerType === 'leaflet');
                    }
                });

                // Gew√§hlten Layer anzeigen
                switch (layerType) {
                    case 'leaflet':
                        document.getElementById('leafletMap').classList.remove('hidden');
                        setTimeout(() => {
                            this.leafletMap.invalidateSize();
                        }, 100);
                        break;
                        
                    case 'kystinfo':
                        document.getElementById('kystinfoFrame').classList.remove('hidden');
                        this.syncOverlays();
                        break;
                        
                    case 'pdf':
                        document.getElementById('pdfViewer').classList.remove('hidden');
                        if (!this.pdfDoc) {
                            await this.loadPDF();
                        }
                        this.syncOverlays();
                        break;
                }
            }

            async loadPDF() {
                try {
                    // Standard PDF URL aus Einstellungen
                    const urls = await app.db.getSetting('customMapUrls') || '';
                    const pdfUrl = urls.split('\n')[0]?.trim() || 'https://raw.githack.com/Jamancode/jamancode.github.io/main/Karten/West_best.pdf';
                    
                    const loadingTask = pdfjsLib.getDocument(pdfUrl);
                    this.pdfDoc = await loadingTask.promise;
                    
                    // Erste Seite rendern
                    this.renderPDFPage(1);
                    
                } catch (error) {
                    console.error('Fehler beim Laden der PDF:', error);
                    app.showToast('PDF konnte nicht geladen werden', 'error');
                }
            }

            async renderPDFPage(pageNum) {
                if (!this.pdfDoc) return;

                try {
                    this.pdfPage = await this.pdfDoc.getPage(pageNum);
                    const canvas = document.getElementById('pdfCanvas');
                    const context = canvas.getContext('2d');
                    
                    const viewport = this.pdfPage.getViewport({ scale: this.pdfScale });
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };
                    
                    await this.pdfPage.render(renderContext).promise;
                    
                } catch (error) {
                    console.error('Fehler beim Rendern der PDF-Seite:', error);
                }
            }

            setupPDFPan() {
                const canvas = document.getElementById('pdfCanvas');
                const viewer = document.getElementById('pdfViewer');
                let isPanning = false;
                let startX, startY;

                canvas.addEventListener('mousedown', (e) => {
                    isPanning = true;
                    startX = e.clientX - this.pdfOffset.x;
                    startY = e.clientY - this.pdfOffset.y;
                    canvas.classList.add('grabbing');
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isPanning) return;
                    
                    this.pdfOffset.x = e.clientX - startX;
                    this.pdfOffset.y = e.clientY - startY;
                    
                    canvas.style.transform = `translate(${this.pdfOffset.x}px, ${this.pdfOffset.y}px)`;
                });

                window.addEventListener('mouseup', () => {
                    isPanning = false;
                    canvas.classList.remove('grabbing');
                });

                // Touch-Events f√ºr mobile Ger√§te
                let touch = null;
                canvas.addEventListener('touchstart', (e) => {
                    touch = e.touches[0];
                    startX = touch.clientX - this.pdfOffset.x;
                    startY = touch.clientY - this.pdfOffset.y;
                });

                canvas.addEventListener('touchmove', (e) => {
                    if (!touch) return;
                    e.preventDefault();
                    
                    const currentTouch = e.touches[0];
                    this.pdfOffset.x = currentTouch.clientX - startX;
                    this.pdfOffset.y = currentTouch.clientY - startY;
                    
                    canvas.style.transform = `translate(${this.pdfOffset.x}px, ${this.pdfOffset.y}px)`;
                });

                canvas.addEventListener('touchend', () => {
                    touch = null;
                });
            }

            zoomPDF(factor) {
                this.pdfScale *= factor;
                this.pdfScale = Math.max(0.5, Math.min(3, this.pdfScale));
                this.renderPDFPage(1);
            }

            resetPDFZoom() {
                this.pdfScale = 1;
                this.pdfOffset = { x: 0, y: 0 };
                document.getElementById('pdfCanvas').style.transform = '';
                this.renderPDFPage(1);
            }

            syncOverlays() {
                // GPS-Track und Marker auf nicht-Leaflet Karten synchronisieren
                if (this.currentLayer === 'leaflet') return;

                // Implementierung f√ºr Overlay-Synchronisation
                this.updateGPSTrackOverlay();
                this.updateMarkerOverlay();
            }

            updateGPSTrackOverlay() {
                const svg = document.getElementById('gpsTrackSvg');
                if (!svg || !app.gps.trackPoints.length) return;

                // SVG-Path f√ºr GPS-Track erstellen
                const points = app.gps.trackPoints;
                const pathData = points.map((point, index) => {
                    const coords = this.projectToOverlay(point.lat, point.lng);
                    return `${index === 0 ? 'M' : 'L'} ${coords.x} ${coords.y}`;
                }).join(' ');

                svg.innerHTML = `
                    <path d="${pathData}" 
                          stroke="#ff6b35" 
                          stroke-width="3" 
                          fill="none" 
                          opacity="0.8"/>
                `;
            }

            updateMarkerOverlay() {
                const overlay = document.getElementById('markerOverlay');
                if (!overlay) return;

                overlay.innerHTML = '';

                this.markers.forEach(marker => {
                    const coords = this.projectToOverlay(marker.lat, marker.lng);
                    
                    const markerEl = document.createElement('div');
                    markerEl.className = `overlay-marker ${marker.favorite ? 'favorite' : ''}`;
                    markerEl.style.left = `${coords.x}px`;
                    markerEl.style.top = `${coords.y}px`;
                    markerEl.title = marker.name;
                    
                    if (marker.name) {
                        const label = document.createElement('div');
                        label.className = 'overlay-marker-label';
                        label.textContent = marker.name;
                        markerEl.appendChild(label);
                    }
                    
                    overlay.appendChild(markerEl);
                });
            }

            projectToOverlay(lat, lng) {
                // Vereinfachte Projektion f√ºr Overlays
                // In der Praxis w√ºrde man hier eine richtige Kartenprojektion verwenden
                const container = document.getElementById('mapContainer');
                const bounds = container.getBoundingClientRect();
                
                // Annahme: Karte zeigt Bereich um Leka
                const centerLat = APP_CONFIG.defaultLocation.lat;
                const centerLng = APP_CONFIG.defaultLocation.lng;
                
                const x = bounds.width / 2 + (lng - centerLng) * 1000;
                const y = bounds.height / 2 - (lat - centerLat) * 1000;
                
                return { x, y };
            }

            updateUserPosition(position) {
                if (!this.leafletMap) {
                    console.warn('Map nicht initialisiert');
                    return;
                }

                // Entferne alten Marker
                if (this.userMarker) {
                    this.leafletMap.removeLayer(this.userMarker);
                }

                // Neuen Marker erstellen
                const icon = L.divIcon({
                    className: 'custom-marker',
                    html: '<div style="background: #0084b4; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });

                try {
                    this.userMarker = L.marker([position.lat, position.lng], { icon })
                        .addTo(this.leafletMap);

                    // Genauigkeitskreis
                    if (this.accuracyCircle) {
                        this.leafletMap.removeLayer(this.accuracyCircle);
                    }

                    this.accuracyCircle = L.circle([position.lat, position.lng], {
                        radius: position.accuracy,
                        color: '#0084b4',
                        fillColor: '#0084b4',
                        fillOpacity: 0.1,
                        weight: 1
                    }).addTo(this.leafletMap);
                } catch (error) {
                    console.error('Fehler beim Aktualisieren der Position auf der Karte:', error);
                }
            }

            centerOnPosition(position) {
                if (!position) {
                    position = app.gps.currentPosition;
                }

                if (!position) {
                    app.showToast('Keine GPS-Position verf√ºgbar', 'warning');
                    
                    // Versuche GPS zu aktivieren
                    if (!app.gps.isTracking) {
                        app.showToast('GPS wird aktiviert...', 'info');
                        app.startGPS().then(() => {
                            // Warte auf erste Position
                            setTimeout(() => {
                                if (app.gps.currentPosition) {
                                    this.leafletMap.setView([app.gps.currentPosition.lat, app.gps.currentPosition.lng], 16);
                                }
                            }, 2000);
                        }).catch(error => {
                            console.error('GPS Start fehlgeschlagen:', error);
                        });
                    }
                    return;
                }

                if (this.leafletMap) {
                    try {
                        this.leafletMap.setView([position.lat, position.lng], 16);
                    } catch (error) {
                        console.error('Fehler beim Zentrieren der Karte:', error);
                    }
                }
            }

            async addMarker(markerData) {
                try {
                    // In Datenbank speichern
                    const id = await app.db.saveMarker(markerData);
                    markerData.id = id;
                    
                    // Auf Karte hinzuf√ºgen
                    this.displayMarker(markerData);
                    this.markers.push(markerData);
                    
                    // Overlays aktualisieren
                    this.syncOverlays();
                    
                    return id;
                } catch (error) {
                    console.error('Fehler beim Hinzuf√ºgen des Markers:', error);
                    throw error;
                }
            }

            displayMarker(markerData) {
                if (!this.leafletMap) return;

                const icon = L.divIcon({
                    className: 'custom-marker',
                    html: `<div style="background: ${markerData.favorite ? 'gold' : '#ff6b35'}; width: 30px; height: 30px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 30]
                });

                const marker = L.marker([markerData.lat, markerData.lng], { icon })
                    .addTo(this.leafletMap);

                // Popup
                const popupContent = `
                    <div style="min-width: 200px;">
                        <h4>${markerData.name}</h4>
                        ${markerData.depth ? `<p>Tiefe: ${markerData.depth}m</p>` : ''}
                        ${markerData.ground ? `<p>Grund: ${markerData.ground}</p>` : ''}
                        ${markerData.notes ? `<p>${markerData.notes}</p>` : ''}
                        <button class="btn btn-small btn-danger" onclick="app.map.removeMarker(${markerData.id})">
                            L√∂schen
                        </button>
                    </div>
                `;

                marker.bindPopup(popupContent);
                marker._customId = markerData.id;
            }

            async removeMarker(id) {
                if (!confirm('Marker wirklich l√∂schen?')) return;

                try {
                    await app.db.deleteMarker(id);
                    
                    // Von Karte entfernen
                    this.leafletMap.eachLayer(layer => {
                        if (layer._customId === id) {
                            this.leafletMap.removeLayer(layer);
                        }
                    });
                    
                    // Aus Array entfernen
                    this.markers = this.markers.filter(m => m.id !== id);
                    
                    // Listen aktualisieren
                    app.updateSpotsList();
                    this.syncOverlays();
                    
                    app.showToast('Marker gel√∂scht', 'info');
                } catch (error) {
                    console.error('Fehler beim L√∂schen:', error);
                    app.showToast('L√∂schen fehlgeschlagen', 'error');
                }
            }

            async loadMarkers() {
                try {
                    const markers = await app.db.getMarkers();
                    this.markers = markers;
                    
                    markers.forEach(marker => {
                        this.displayMarker(marker);
                    });
                    
                    this.syncOverlays();
                } catch (error) {
                    console.error('Fehler beim Laden der Marker:', error);
                }
            }
        }

        // ====================================
        // HAUPTANWENDUNG
        // ====================================
        class HochseeangelnApp {
            constructor() {
                this.db = new DatabaseManager();
                this.gps = new GPSManager();
                this.weather = new WeatherManager();
                this.route = new RouteManager();
                this.map = new MapManager();
                this.isEmergencyMode = false;
                this.autosaveInterval = null;
            }

            async init() {
                try {
                    // Loading anzeigen
                    this.showLoading(true);
                    
                    // Datenbank initialisieren
                    await this.db.init();
                    console.log('Datenbank initialisiert');
                    
                    // Einstellungen laden
                    await this.loadSettings();
                    
                    // Karte initialisieren
                    await this.map.init();
                    await this.map.loadMarkers();
                    console.log('Karte initialisiert');
                    
                    // Wetter initialisieren
                    await this.weather.init();
                    
                    // Event Listener einrichten
                    this.setupEventListeners();
                    
                    // UI initialisieren
                    this.initializeUI();
                    
                    // Service Worker registrieren
                    this.registerServiceWorker();
                    
                    // Autosave starten
                    this.startAutosave();
                    
                    // Offline-Status √ºberwachen
                    this.monitorOfflineStatus();
                    
                    // Loading ausblenden
                    this.showLoading(false);
                    
                    // GPS-Permission anfragen (nach UI-Initialisierung)
                    setTimeout(async () => {
                        if ('geolocation' in navigator) {
                            try {
                                // Erkenne iOS
                                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                                
                                // Auf iOS direkt Permission anfragen ohne vorherige Pr√ºfung
                                if (isIOS) {
                                    console.log('iOS erkannt - direkte Permission-Anfrage');
                                    const granted = await this.gps.requestPermission();
                                    if (granted) {
                                        const autoGps = await this.db.getSetting('autoGps');
                                        if (autoGps === 'true' || autoGps === true) {
                                            await this.startGPS();
                                        }
                                    }
                                    return;
                                }
                                
                                // Andere Browser: Pr√ºfe Permission-Status wenn verf√ºgbar
                                if (navigator.permissions && navigator.permissions.query) {
                                    try {
                                        const permission = await navigator.permissions.query({ name: 'geolocation' });
                                        console.log('GPS Permission Status:', permission.state);
                                        
                                        if (permission.state === 'granted') {
                                            this.gps.hasPermission = true;
                                            const autoGps = await this.db.getSetting('autoGps');
                                            if (autoGps === 'true' || autoGps === true) {
                                                await this.startGPS();
                                            }
                                        } else if (permission.state === 'prompt') {
                                            const granted = await this.gps.requestPermission();
                                            if (granted) {
                                                const autoGps = await this.db.getSetting('autoGps');
                                                if (autoGps === 'true' || autoGps === true) {
                                                    await this.startGPS();
                                                }
                                            }
                                        } else {
                                            console.log('GPS-Berechtigung verweigert');
                                            this.showToast('GPS-Berechtigung verweigert. Bitte in den Einstellungen aktivieren.', 'warning');
                                        }
                                    } catch (error) {
                                        // Fallback
                                        console.log('Permissions API Fehler, zeige Dialog');
                                        const granted = await this.gps.requestPermission();
                                        if (granted) {
                                            const autoGps = await this.db.getSetting('autoGps');
                                            if (autoGps === 'true' || autoGps === true) {
                                                await this.startGPS();
                                            }
                                        }
                                    }
                                } else {
                                    // Kein Permissions API
                                    const granted = await this.gps.requestPermission();
                                    if (granted) {
                                        const autoGps = await this.db.getSetting('autoGps');
                                        if (autoGps === 'true' || autoGps === true) {
                                            await this.startGPS();
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('GPS-Initialisierungsfehler:', error);
                            }
                        } else {
                            this.showToast('GPS wird von diesem Ger√§t nicht unterst√ºtzt', 'warning');
                        }
                    }, 1500); // Etwas l√§ngere Verz√∂gerung f√ºr iOS
                    
                    console.log('App erfolgreich initialisiert');
                    
                } catch (error) {
                    console.error('Fehler bei der Initialisierung:', error);
                    this.showCriticalError('Initialisierungsfehler: ' + error.message);
                }
            }

            setupEventListeners() {
                // Navigation
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchSection(e.currentTarget.dataset.section);
                    });
                });

                // GPS Controls
                document.getElementById('gpsToggle').addEventListener('click', () => this.toggleGPS());
                document.getElementById('centerMap').addEventListener('click', () => this.map.centerOnPosition());
                document.getElementById('trackToggle').addEventListener('click', () => this.toggleTracking());
                document.getElementById('gpsInfoToggle').addEventListener('click', () => this.toggleGPSInfo());
                document.getElementById('fullscreenMap').addEventListener('click', () => this.toggleFullscreen());

                // Marker
                document.getElementById('addMarkerBtn').addEventListener('click', () => this.showPositionSelector());
                document.getElementById('cancelPositionSelect').addEventListener('click', () => this.hidePositionSelector());
                document.getElementById('selectCurrentPosition').addEventListener('click', () => this.selectCurrentPosition());
                document.getElementById('selectMapPosition').addEventListener('click', () => this.selectMapPosition());
                document.getElementById('selectManualPosition').addEventListener('click', () => this.selectManualPosition());

                // Marker Form
                document.getElementById('markerForm').addEventListener('submit', (e) => this.saveMarker(e));
                document.getElementById('closeMarkerModal').addEventListener('click', () => this.closeModal('markerModal'));
                document.getElementById('updateMarkerGPS').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.updateMarkerGPS();
                });
                document.getElementById('markerTestGPS').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.testGPS();
                });

                // F√§nge
                document.getElementById('addCatch').addEventListener('click', () => this.showCatchModal());
                document.getElementById('catchForm').addEventListener('submit', (e) => this.saveCatch(e));
                document.getElementById('closeCatchModal').addEventListener('click', () => this.closeModal('catchModal'));
                document.getElementById('updateCatchGPS').addEventListener('click', () => this.updateCatchGPS());
                document.getElementById('catchFromCurrentPosition').addEventListener('click', () => this.setCatchCurrentPosition());
                document.getElementById('catchPhoto').addEventListener('change', (e) => this.previewPhoto(e));

                // Route
                document.getElementById('startRoute').addEventListener('click', () => this.route.startRecording());
                document.getElementById('stopRoute').addEventListener('click', () => this.route.stopRecording());
                document.getElementById('saveRoute').addEventListener('click', () => this.route.saveRoute());

                // Einstellungen
                document.getElementById('saveSettings').addEventListener('click', () => this.saveSettings());
                document.getElementById('backupData').addEventListener('click', () => this.backupData());
                document.getElementById('restoreData').addEventListener('click', () => this.restoreData());
                document.getElementById('testAlerts').addEventListener('click', () => this.testAlerts());
                document.getElementById('clearData').addEventListener('click', () => this.clearAllData());
                document.getElementById('copyLekaCoords').addEventListener('click', () => this.copyCoords('lekaCoords'));

                // Import/Export
                document.getElementById('exportSpots').addEventListener('click', () => this.exportSpots());
                document.getElementById('importSpots').addEventListener('click', () => this.importSpots());

                // Notfall
                document.getElementById('emergencyButton').addEventListener('click', () => this.activateEmergency());
                document.getElementById('closeEmergencyModal').addEventListener('click', () => this.deactivateEmergency());
                document.getElementById('copyEmergencyCoords').addEventListener('click', () => this.copyCoords('emergencyCoords'));
                document.getElementById('sendEmergencyPosition').addEventListener('click', () => this.sendEmergencyPosition());

                // GPS Callbacks
                this.gps.onPositionUpdate((position) => {
                    this.map.updateUserPosition(position);
                    this.updateEmergencyPosition(position);
                });

                // Window Events
                window.addEventListener('beforeunload', (e) => {
                    if (this.hasUnsavedChanges()) {
                        e.preventDefault();
                        e.returnValue = '';
                    }
                });
            }

            initializeUI() {
                // Fischarten-Grids f√ºllen
                this.populateFishGrids();
                
                // Listen aktualisieren
                this.updateSpotsList();
                this.updateCatchList();
                this.route.loadSavedRoutes();
                
                // Statistiken aktualisieren
                this.updateStatistics();
                
                // Datum/Zeit setzen
                const now = new Date();
                document.getElementById('catchDateTime').value = now.toISOString().slice(0, 16);
            }

            populateFishGrids() {
                const grids = ['markerFishGrid', 'catchFishGrid'];
                
                grids.forEach(gridId => {
                    const grid = document.getElementById(gridId);
                    if (!grid) return;
                    
                    grid.innerHTML = '';
                    
                    Object.entries(FISH_DATABASE).forEach(([key, fish]) => {
                        const item = document.createElement('div');
                        item.className = 'fish-species-item';
                        item.dataset.species = key;
                        
                        item.innerHTML = `
                            <div class="fish-species-icon">${fish.icon}</div>
                            <div class="fish-species-name">${fish.name}</div>
                        `;
                        
                        item.addEventListener('click', () => {
                            if (gridId === 'catchFishGrid') {
                                // Bei Fang nur eine Art w√§hlbar
                                grid.querySelectorAll('.selected').forEach(el => {
                                    el.classList.remove('selected');
                                });
                                item.classList.add('selected');
                                document.getElementById('catchFishType').value = key;
                            } else {
                                // Bei Marker mehrere Arten w√§hlbar
                                item.classList.toggle('selected');
                            }
                        });
                        
                        grid.appendChild(item);
                    });
                });
            }

            switchSection(section) {
                // Alle Sections verstecken
                document.querySelectorAll('.content-section').forEach(el => {
                    el.classList.remove('active');
                });
                
                // Alle Tabs deaktivieren
                document.querySelectorAll('.nav-tab').forEach(el => {
                    el.classList.remove('active');
                });
                
                // Gew√§hlte Section anzeigen
                document.getElementById(`${section}-section`).classList.add('active');
                document.querySelector(`[data-section="${section}"]`).classList.add('active');
                
                // Spezielle Aktionen pro Section
                if (section === 'weather') {
                    this.updateWeather();
                }
            }

            // GPS-Funktionen
            async startGPS() {
                try {
                    // Pr√ºfe ob Geolocation verf√ºgbar ist
                    if (!navigator.geolocation) {
                        throw new Error('GPS wird von diesem Ger√§t nicht unterst√ºtzt');
                    }

                    const accuracy = await this.db.getSetting('gpsAccuracy') || 'high';
                    await this.gps.startTracking(accuracy);
                    
                    // Button aktualisieren
                    const btn = document.getElementById('gpsToggle');
                    if (btn) {
                        btn.classList.add('active');
                        btn.innerHTML = '<span>üìç</span>';
                    }
                    
                    this.showToast('GPS aktiviert', 'success');
                } catch (error) {
                    console.error('GPS-Fehler:', error);
                    
                    // Spezifische Fehlermeldungen
                    let errorMessage = 'GPS konnte nicht aktiviert werden';
                    
                    if (error.code === 1 || error.message.includes('denied')) {
                        errorMessage = 'GPS-Berechtigung verweigert. Bitte in den Browsereinstellungen erlauben.';
                    } else if (error.code === 2 || error.message.includes('unavailable')) {
                        errorMessage = 'GPS-Signal nicht verf√ºgbar. Bitte Standortdienste aktivieren.';
                    } else if (error.code === 3 || error.message.includes('timeout')) {
                        errorMessage = 'GPS-Timeout. Schwaches Signal.';
                    }
                    
                    this.showToast(errorMessage, 'error');
                    
                    // Zeige GPS Permission Modal erneut
                    if (error.code === 1 || error.message.includes('denied')) {
                        setTimeout(() => {
                            this.gps.requestPermission();
                        }, 1000);
                    }
                }
            }

            toggleGPS() {
                if (this.gps.isTracking) {
                    this.gps.stopTracking();
                    const btn = document.getElementById('gpsToggle');
                    if (btn) {
                        btn.classList.remove('active');
                    }
                    this.showToast('GPS deaktiviert', 'info');
                } else {
                    // Starte GPS mit Fehlerbehandlung
                    this.startGPS().catch(error => {
                        console.error('GPS Toggle Error:', error);
                        const btn = document.getElementById('gpsToggle');
                        if (btn) {
                            btn.classList.remove('active');
                        }
                    });
                }
            }

            toggleTracking() {
                const btn = document.getElementById('trackToggle');
                
                if (this.route.isRecording) {
                    this.route.stopRecording();
                    btn.classList.remove('active');
                } else {
                    if (!this.gps.isTracking) {
                        this.showToast('Bitte erst GPS aktivieren', 'warning');
                        return;
                    }
                    this.route.startRecording();
                    btn.classList.add('active');
                }
            }

            toggleGPSInfo() {
                const panel = document.getElementById('gpsInfoPanel');
                if (panel) {
                    panel.classList.toggle('active');
                }
            }

            toggleFullscreen() {
                const mapContainer = document.getElementById('mapContainer');
                
                if (!document.fullscreenElement) {
                    mapContainer.requestFullscreen().catch(err => {
                        console.error('Vollbild-Fehler:', err);
                    });
                } else {
                    document.exitFullscreen();
                }
            }

            // Marker-Funktionen
            showPositionSelector() {
                document.getElementById('positionSelector').classList.add('active');
                
                // Aktuelle Position anzeigen
                const info = document.getElementById('currentPositionInfo');
                if (this.gps.currentPosition) {
                    info.textContent = `${this.gps.currentPosition.lat.toFixed(6)}, ${this.gps.currentPosition.lng.toFixed(6)}`;
                } else if (this.gps.isTracking) {
                    info.textContent = 'GPS aktiv - warte auf Signal...';
                } else {
                    info.textContent = 'GPS nicht aktiv';
                }
            }

            hidePositionSelector() {
                document.getElementById('positionSelector').classList.remove('active');
            }

            selectCurrentPosition() {
                if (!this.gps.currentPosition) {
                    this.showToast('Keine GPS-Position verf√ºgbar', 'error');
                    
                    // Versuche GPS zu aktivieren
                    if (!this.gps.isTracking) {
                        this.showToast('GPS wird aktiviert...', 'info');
                        this.startGPS().then(() => {
                            // Warte auf erste Position
                            setTimeout(() => {
                                if (this.gps.currentPosition) {
                                    this.hidePositionSelector();
                                    this.showMarkerModal(this.gps.currentPosition);
                                } else {
                                    this.showToast('GPS-Position noch nicht verf√ºgbar. Bitte erneut versuchen.', 'warning');
                                }
                            }, 3000);
                        }).catch(error => {
                            this.showToast('GPS konnte nicht aktiviert werden', 'error');
                        });
                    } else {
                        this.showToast('Warte auf GPS-Signal...', 'info');
                    }
                    return;
                }
                
                this.hidePositionSelector();
                this.showMarkerModal(this.gps.currentPosition);
            }

            selectMapPosition() {
                this.hidePositionSelector();
                this.showToast('Klicken Sie auf die Karte', 'info');
                
                // Einmal-Klick-Handler f√ºr Karte
                const handler = (e) => {
                    this.showMarkerModal({ lat: e.latlng.lat, lng: e.latlng.lng });
                    this.map.leafletMap.off('click', handler);
                };
                
                this.map.leafletMap.on('click', handler);
            }

            selectManualPosition() {
                this.hidePositionSelector();
                
                const lat = prompt('Breitengrad (z.B. 65.0960):');
                const lng = prompt('L√§ngengrad (z.B. 11.7000):');
                
                if (lat && lng) {
                    const position = {
                        lat: parseFloat(lat),
                        lng: parseFloat(lng)
                    };
                    
                    if (!isNaN(position.lat) && !isNaN(position.lng)) {
                        this.showMarkerModal(position);
                    } else {
                        this.showToast('Ung√ºltige Koordinaten', 'error');
                    }
                }
            }

            showMarkerModal(position) {
                // Position setzen
                document.getElementById('markerCoords').value = `${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`;
                
                // Modal √∂ffnen
                document.getElementById('markerModal').classList.add('active');
                
                // Fokus auf Name-Feld
                document.getElementById('markerName').focus();
            }

            async saveMarker(event) {
                event.preventDefault();
                
                try {
                    // Daten sammeln
                    const coords = document.getElementById('markerCoords').value.split(',').map(c => parseFloat(c.trim()));
                    const selectedFish = Array.from(document.querySelectorAll('#markerFishGrid .selected'))
                        .map(el => el.dataset.species);
                    
                    const markerData = {
                        name: document.getElementById('markerName').value,
                        lat: coords[0],
                        lng: coords[1],
                        depth: document.getElementById('markerDepth').value || null,
                        ground: document.getElementById('markerGround').value || null,
                        fishTypes: selectedFish,
                        current: document.getElementById('markerCurrent').value || null,
                        tide: document.getElementById('markerTide').value || null,
                        notes: document.getElementById('markerNotes').value || null,
                        favorite: document.getElementById('markerFavorite').checked,
                        created: new Date().toISOString()
                    };
                    
                    // Pr√ºfen ob Update oder neuer Marker
                    const form = document.getElementById('markerForm');
                    const editId = form.dataset.editId;
                    
                    if (editId) {
                        // Update
                        markerData.id = parseInt(editId);
                        markerData.created = undefined; // Behalte urspr√ºngliches Datum
                        markerData.updated = new Date().toISOString();
                        
                        // Marker von Karte entfernen
                        this.map.removeMarker(editId);
                    }
                    
                    // Speichern
                    await this.map.addMarker(markerData);
                    
                    // Modal schlie√üen
                    this.closeModal('markerModal');
                    
                    // Formular zur√ºcksetzen
                    document.getElementById('markerForm').reset();
                    document.querySelectorAll('#markerFishGrid .selected').forEach(el => {
                        el.classList.remove('selected');
                    });
                    delete form.dataset.editId;
                    
                    // Listen aktualisieren
                    this.updateSpotsList();
                    
                    this.showToast(editId ? 'Angelplatz aktualisiert' : 'Angelplatz gespeichert', 'success');
                    
                } catch (error) {
                    console.error('Fehler beim Speichern:', error);
                    this.showToast('Fehler beim Speichern', 'error');
                }
            }

            updateMarkerGPS() {
                if (!this.gps.currentPosition) {
                    this.showToast('Keine GPS-Position verf√ºgbar', 'error');
                    
                    // Versuche GPS zu aktivieren
                    if (!this.gps.isTracking) {
                        this.showToast('GPS wird aktiviert...', 'info');
                        this.startGPS().then(() => {
                            // Warte kurz auf erste Position
                            setTimeout(() => {
                                if (this.gps.currentPosition) {
                                    document.getElementById('markerCoords').value = 
                                        `${this.gps.currentPosition.lat.toFixed(6)}, ${this.gps.currentPosition.lng.toFixed(6)}`;
                                    this.showToast('Position aktualisiert', 'success');
                                }
                            }, 2000);
                        }).catch(error => {
                            console.error('GPS Start fehlgeschlagen:', error);
                        });
                    }
                    return;
                }
                
                document.getElementById('markerCoords').value = 
                    `${this.gps.currentPosition.lat.toFixed(6)}, ${this.gps.currentPosition.lng.toFixed(6)}`;
                    
                this.showToast('Position aktualisiert', 'success');
            }

            testGPS() {
                if (!this.gps.isTracking) {
                    this.showToast('GPS ist nicht aktiv', 'warning');
                    
                    if (confirm('GPS aktivieren?')) {
                        this.startGPS().then(() => {
                            setTimeout(() => {
                                this.showGPSInfo();
                            }, 2000);
                        }).catch(error => {
                            this.showToast('GPS konnte nicht aktiviert werden', 'error');
                        });
                    }
                    return;
                }
                
                this.showGPSInfo();
            }

            showGPSInfo() {
                const info = `
GPS-Status: ${this.gps.isTracking ? 'Aktiv' : 'Inaktiv'}
Position: ${this.gps.currentPosition ? 
    `${this.gps.currentPosition.lat.toFixed(6)}, ${this.gps.currentPosition.lng.toFixed(6)}` : 
    'Nicht verf√ºgbar'}
Genauigkeit: ${this.gps.accuracy ? `¬±${this.gps.accuracy.toFixed(1)}m` : 'Unbekannt'}
Satelliten: ${this.gps.satelliteInfo.count}
Qualit√§t: ${this.gps.satelliteInfo.quality}
                `.trim();
                
                alert(info);
            }

            // Fang-Funktionen
            showCatchModal() {
                // Aktuelle Zeit setzen
                const now = new Date();
                document.getElementById('catchDateTime').value = now.toISOString().slice(0, 16);
                
                // GPS-Position setzen
                if (this.gps.currentPosition) {
                    document.getElementById('catchGPS').value = 
                        `${this.gps.currentPosition.lat.toFixed(6)}, ${this.gps.currentPosition.lng.toFixed(6)}`;
                }
                
                // Angelpl√§tze laden
                this.loadSpotsForCatch();
                
                // Wetter laden
                this.loadWeatherForCatch();
                
                // Modal √∂ffnen
                document.getElementById('catchModal').classList.add('active');
            }

            async loadSpotsForCatch() {
                const select = document.getElementById('catchSpot');
                select.innerHTML = '<option value="">-- Kein spezifischer Platz --</option>';
                
                try {
                    const spots = await this.db.getMarkers();
                    spots.forEach(spot => {
                        const option = document.createElement('option');
                        option.value = spot.id;
                        option.textContent = spot.name;
                        select.appendChild(option);
                    });
                } catch (error) {
                    console.error('Fehler beim Laden der Angelpl√§tze:', error);
                }
            }

            loadWeatherForCatch() {
                const summary = document.getElementById('catchWeatherSummary');
                
                if (this.weather.currentWeather) {
                    const w = this.weather.currentWeather;
                    summary.innerHTML = `
                        <strong>Aktuelles Wetter:</strong><br>
                        ${w.weather[0].description}, ${Math.round(w.main.temp)}¬∞C<br>
                        Wind: ${Math.round(w.wind.speed * 3.6)} km/h<br>
                        Luftdruck: ${w.main.pressure} hPa
                    `;
                } else {
                    summary.innerHTML = '<em>Wetterdaten nicht verf√ºgbar</em>';
                }
            }

            async saveCatch(event) {
                event.preventDefault();
                
                try {
                    const coords = document.getElementById('catchGPS').value.split(',').map(c => parseFloat(c.trim()));
                    const photoInput = document.getElementById('catchPhoto');
                    let photoData = null;
                    
                    // Foto verarbeiten
                    if (photoInput.files.length > 0) {
                        photoData = await this.processPhoto(photoInput.files[0]);
                    }
                    
                    const catchData = {
                        dateTime: document.getElementById('catchDateTime').value,
                        fishType: document.getElementById('catchFishType').value,
                        weight: parseFloat(document.getElementById('catchWeight').value) || null,
                        length: parseInt(document.getElementById('catchLength').value) || null,
                        lat: coords[0],
                        lng: coords[1],
                        spotId: document.getElementById('catchSpot').value || null,
                        bait: document.getElementById('catchBait').value || null,
                        depth: parseInt(document.getElementById('catchDepth').value) || null,
                        weather: this.weather.currentWeather ? {
                            temp: this.weather.currentWeather.main.temp,
                            description: this.weather.currentWeather.weather[0].description,
                            wind: this.weather.currentWeather.wind.speed,
                            pressure: this.weather.currentWeather.main.pressure
                        } : null,
                        photo: photoData,
                        notes: document.getElementById('catchNotes').value || null,
                        released: document.getElementById('catchReleased').checked,
                        created: new Date().toISOString()
                    };
                    
                    // Speichern
                    await this.db.saveCatch(catchData);
                    
                    // Modal schlie√üen
                    this.closeModal('catchModal');
                    
                    // Formular zur√ºcksetzen
                    document.getElementById('catchForm').reset();
                    document.getElementById('photoPreview').innerHTML = '';
                    document.querySelectorAll('#catchFishGrid .selected').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    // Listen aktualisieren
                    this.updateCatchList();
                    
                    this.showToast('Fang gespeichert', 'success');
                    
                } catch (error) {
                    console.error('Fehler beim Speichern:', error);
                    this.showToast('Fehler beim Speichern', 'error');
                }
            }

            async processPhoto(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        // Bild komprimieren
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Max. Gr√∂√üe
                            const maxWidth = 1200;
                            const maxHeight = 1200;
                            let width = img.width;
                            let height = img.height;
                            
                            if (width > height) {
                                if (width > maxWidth) {
                                    height *= maxWidth / width;
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width *= maxHeight / height;
                                    height = maxHeight;
                                }
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Als JPEG mit reduzierter Qualit√§t
                            canvas.toBlob((blob) => {
                                const compressedReader = new FileReader();
                                compressedReader.onload = (e) => {
                                    resolve(e.target.result);
                                };
                                compressedReader.readAsDataURL(blob);
                            }, 'image/jpeg', 0.8);
                        };
                        
                        img.src = e.target.result;
                    };
                    
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            previewPhoto(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('photoPreview').innerHTML = 
                        `<img src="${e.target.result}" alt="Vorschau">`;
                };
                reader.readAsDataURL(file);
            }

            updateCatchGPS() {
                if (!this.gps.currentPosition) {
                    this.showToast('Keine GPS-Position verf√ºgbar', 'error');
                    return;
                }
                
                document.getElementById('catchGPS').value = 
                    `${this.gps.currentPosition.lat.toFixed(6)}, ${this.gps.currentPosition.lng.toFixed(6)}`;
                    
                this.showToast('Position aktualisiert', 'success');
            }

            setCatchCurrentPosition() {
                if (!this.gps.currentPosition) {
                    this.showToast('Keine GPS-Position verf√ºgbar', 'error');
                    
                    // Versuche GPS zu aktivieren
                    if (!this.gps.isTracking) {
                        this.showToast('GPS wird aktiviert...', 'info');
                        this.startGPS().then(() => {
                            // Warte auf erste Position
                            setTimeout(() => {
                                if (this.gps.currentPosition) {
                                    this.updateCatchGPS();
                                    this.loadWeatherForCatch();
                                }
                            }, 2000);
                        }).catch(error => {
                            console.error('GPS Start fehlgeschlagen:', error);
                        });
                    }
                    return;
                }
                
                this.updateCatchGPS();
                this.loadWeatherForCatch();
            }

            // Wetter-Funktionen
            async updateWeather() {
                try {
                    let position = this.gps.currentPosition || APP_CONFIG.defaultLocation;
                    
                    await this.weather.updateWeather(position.lat, position.lng);
                    await this.weather.getTideData(position.lat, position.lng);
                    
                    // Fisch-Vorhersage
                    const forecast = this.weather.getFishingForecast();
                    if (forecast) {
                        this.displayFishingForecast(forecast);
                    }
                    
                } catch (error) {
                    console.error('Fehler beim Abrufen der Wetterdaten:', error);
                    this.showToast('Wetterdaten konnten nicht geladen werden', 'error');
                }
            }

            displayFishingForecast(forecast) {
                const container = document.getElementById('fishingForecast');
                if (!container) return;
                
                let quality = 'Schlecht';
                let color = 'var(--accent-red)';
                
                if (forecast.score >= 80) {
                    quality = 'Exzellent';
                    color = 'var(--accent-green)';
                } else if (forecast.score >= 60) {
                    quality = 'Gut';
                    color = 'var(--accent-green)';
                } else if (forecast.score >= 40) {
                    quality = 'Mittel';
                    color = 'var(--accent-yellow)';
                }
                
                container.innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 3rem; color: ${color}; font-weight: bold;">
                            ${forecast.score}%
                        </div>
                        <div style="font-size: 1.5rem; margin-bottom: 1rem;">
                            ${quality}
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary);">
                            <p>Luftdruck: ${forecast.factors.pressure} hPa</p>
                            <p>Wind: ${forecast.factors.wind.toFixed(1)} km/h</p>
                            <p>Bew√∂lkung: ${forecast.factors.clouds}%</p>
                        </div>
                    </div>
                `;
            }

            // Einstellungen
            async loadSettings() {
                const settings = await this.db.getAllSettings();
                
                // API Keys
                if (settings.openWeatherApiKey) {
                    document.getElementById('openWeatherApiKey').value = settings.openWeatherApiKey;
                }
                if (settings.stormglassApiKey) {
                    document.getElementById('stormglassApiKey').value = settings.stormglassApiKey;
                }
                
                // GPS-Einstellungen
                if (settings.gpsAccuracy) {
                    document.getElementById('gpsAccuracy').value = settings.gpsAccuracy;
                }
                if (settings.gpsUpdateInterval) {
                    document.getElementById('gpsUpdateInterval').value = settings.gpsUpdateInterval;
                }
                if (settings.autoGps !== undefined) {
                    document.getElementById('autoGps').value = settings.autoGps;
                }
                
                // Karten-URLs
                if (settings.customMapUrls) {
                    document.getElementById('customMapUrls').value = settings.customMapUrls;
                }
                
                // Speicher-Statistiken aktualisieren
                this.updateStorageStats();
            }

            async saveSettings() {
                try {
                    // API Keys
                    await this.db.saveSetting('openWeatherApiKey', document.getElementById('openWeatherApiKey').value);
                    await this.db.saveSetting('stormglassApiKey', document.getElementById('stormglassApiKey').value);
                    
                    // GPS-Einstellungen
                    await this.db.saveSetting('gpsAccuracy', document.getElementById('gpsAccuracy').value);
                    await this.db.saveSetting('gpsUpdateInterval', document.getElementById('gpsUpdateInterval').value);
                    await this.db.saveSetting('autoGps', document.getElementById('autoGps').value);
                    
                    // Karten-URLs
                    await this.db.saveSetting('customMapUrls', document.getElementById('customMapUrls').value);
                    
                    // Wetter-Manager neu initialisieren
                    await this.weather.init();
                    
                    this.showToast('Einstellungen gespeichert', 'success');
                    
                } catch (error) {
                    console.error('Fehler beim Speichern der Einstellungen:', error);
                    this.showToast('Fehler beim Speichern', 'error');
                }
            }

            async updateStorageStats() {
                // Gesch√§tzter Speicherverbrauch
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    try {
                        const estimate = await navigator.storage.estimate();
                        const usedMB = (estimate.usage / 1024 / 1024).toFixed(1);
                        document.getElementById('storageUsed').textContent = usedMB;
                    } catch (error) {
                        console.error('Fehler bei Speicher-Sch√§tzung:', error);
                    }
                }
                
                // Letztes Backup
                const lastBackup = await this.db.getSetting('lastBackup');
                if (lastBackup) {
                    const date = new Date(lastBackup);
                    document.getElementById('lastBackup').textContent = date.toLocaleDateString('de-DE');
                }
                
                // Daten-Alter
                const markers = await this.db.getMarkers();
                const catches = await this.db.getCatches();
                const allDates = [...markers, ...catches].map(item => new Date(item.created));
                
                if (allDates.length > 0) {
                    const oldest = Math.min(...allDates);
                    const days = Math.floor((Date.now() - oldest) / 86400000);
                    document.getElementById('dataAge').textContent = days;
                }
            }

            // Listen-Updates
            async updateSpotsList() {
                try {
                    const spots = await this.db.getMarkers();
                    const container = document.getElementById('spotsList');
                    
                    // Statistiken
                    document.getElementById('totalSpots').textContent = spots.length;
                    
                    const today = new Date().toDateString();
                    const todaySpots = spots.filter(s => new Date(s.created).toDateString() === today);
                    document.getElementById('todaySpots').textContent = todaySpots.length;
                    
                    const favorites = spots.filter(s => s.favorite);
                    document.getElementById('favoriteSpots').textContent = favorites.length;
                    
                    // Badge
                    const badge = document.getElementById('spotsBadge');
                    if (badge) {
                        badge.textContent = spots.length;
                        badge.style.display = spots.length > 0 ? 'inline' : 'none';
                    }
                    
                    // Liste
                    if (!container) return;
                    
                    if (spots.length === 0) {
                        container.innerHTML = `
                            <div class="text-center text-muted">
                                <p>Noch keine Angelpl√§tze gespeichert.</p>
                                <p>F√ºgen Sie Marker √ºber die Karte hinzu!</p>
                            </div>
                        `;
                        return;
                    }
                    
                    container.innerHTML = '';
                    
                    // Nach Favoriten und dann nach Datum sortieren
                    spots.sort((a, b) => {
                        if (a.favorite && !b.favorite) return -1;
                        if (!a.favorite && b.favorite) return 1;
                        return new Date(b.created) - new Date(a.created);
                    });
                    
                    spots.forEach(spot => {
                        const spotEl = this.createSpotElement(spot);
                        container.appendChild(spotEl);
                    });
                    
                } catch (error) {
                    console.error('Fehler beim Aktualisieren der Spots-Liste:', error);
                }
            }

            createSpotElement(spot) {
                const el = document.createElement('div');
                el.className = 'marker-item';
                
                const fishList = spot.fishTypes && spot.fishTypes.length > 0 ? 
                    spot.fishTypes.map(type => FISH_DATABASE[type]?.name || type).join(', ') : 
                    'Keine spezifischen Arten';
                
                el.innerHTML = `
                    <div class="item-header">
                        <span class="item-title">
                            ${spot.favorite ? '‚≠ê ' : ''}${spot.name}
                        </span>
                        <span class="text-muted">${new Date(spot.created).toLocaleDateString('de-DE')}</span>
                    </div>
                    <div class="item-meta">
                        <p>üìç ${spot.lat.toFixed(6)}, ${spot.lng.toFixed(6)}</p>
                        ${spot.depth ? `<p>üåä Tiefe: ${spot.depth}m</p>` : ''}
                        ${spot.ground ? `<p>ü™® Grund: ${spot.ground}</p>` : ''}
                        <p>üêü ${fishList}</p>
                        ${spot.notes ? `<p>üìù ${spot.notes}</p>` : ''}
                    </div>
                    <div class="item-actions">
                        <button class="btn btn-small btn-secondary" onclick="app.navigateToSpot(${spot.lat}, ${spot.lng})">
                            <span>üó∫Ô∏è</span> Navigation
                        </button>
                        <button class="btn btn-small btn-secondary" onclick="app.editSpot(${spot.id})">
                            <span>‚úèÔ∏è</span> Bearbeiten
                        </button>
                        <button class="btn btn-small btn-danger" onclick="app.map.removeMarker(${spot.id})">
                            <span>üóëÔ∏è</span> L√∂schen
                        </button>
                    </div>
                `;
                
                return el;
            }

            navigateToSpot(lat, lng) {
                // Zur Karte wechseln
                this.switchSection('map');
                
                // Position zentrieren
                this.map.leafletMap.setView([lat, lng], 16);
                
                // Marker hervorheben
                this.map.leafletMap.eachLayer(layer => {
                    if (layer._latlng && 
                        Math.abs(layer._latlng.lat - lat) < 0.0001 && 
                        Math.abs(layer._latlng.lng - lng) < 0.0001) {
                        layer.openPopup();
                    }
                });
            }

            async updateCatchList() {
                try {
                    const catches = await this.db.getCatches();
                    const container = document.getElementById('catchList');
                    
                    // Statistiken
                    document.getElementById('totalCatches').textContent = catches.length;
                    
                    const today = new Date().toDateString();
                    const todayCatches = catches.filter(c => new Date(c.dateTime).toDateString() === today);
                    document.getElementById('todayCatches').textContent = todayCatches.length;
                    
                    const totalWeight = catches.reduce((sum, c) => sum + (c.weight || 0), 0);
                    document.getElementById('totalWeight').textContent = totalWeight.toFixed(1);
                    
                    // Badge
                    const badge = document.getElementById('catchesBadge');
                    if (badge) {
                        badge.textContent = catches.length;
                        badge.style.display = catches.length > 0 ? 'inline' : 'none';
                    }
                    
                    // Liste
                    if (!container) return;
                    
                    if (catches.length === 0) {
                        container.innerHTML = `
                            <div class="text-center text-muted">
                                <p>Noch keine F√§nge dokumentiert.</p>
                                <p>Tragen Sie Ihren ersten Fang ein!</p>
                            </div>
                        `;
                        return;
                    }
                    
                    container.innerHTML = '';
                    
                    // Nach Datum sortieren (neueste zuerst)
                    catches.sort((a, b) => new Date(b.dateTime) - new Date(a.dateTime));
                    
                    catches.forEach(catchItem => {
                        const catchEl = this.createCatchElement(catchItem);
                        container.appendChild(catchEl);
                    });
                    
                } catch (error) {
                    console.error('Fehler beim Aktualisieren der Fang-Liste:', error);
                }
            }

            createCatchElement(catchItem) {
                const el = document.createElement('div');
                el.className = 'catch-item';
                
                const fish = FISH_DATABASE[catchItem.fishType] || FISH_DATABASE.other;
                const date = new Date(catchItem.dateTime);
                
                let html = `
                    <div class="item-header">
                        <span class="item-title">
                            ${fish.icon} ${fish.name} ${catchItem.released ? 'üîÑ' : ''}
                        </span>
                        <span class="text-muted">
                            ${date.toLocaleDateString('de-DE')} ${date.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'})}
                        </span>
                    </div>
                    <div class="item-meta">
                `;
                
                if (catchItem.weight || catchItem.length) {
                    html += '<p>';
                    if (catchItem.weight) html += `‚öñÔ∏è ${catchItem.weight} kg `;
                    if (catchItem.length) html += `üìè ${catchItem.length} cm`;
                    html += '</p>';
                }
                
                if (catchItem.bait) {
                    html += `<p>üé£ K√∂der: ${catchItem.bait}</p>`;
                }
                
                if (catchItem.depth) {
                    html += `<p>üåä Tiefe: ${catchItem.depth}m</p>`;
                }
                
                if (catchItem.weather) {
                    html += `<p>üå§Ô∏è ${catchItem.weather.description}, ${Math.round(catchItem.weather.temp)}¬∞C, Wind: ${Math.round(catchItem.weather.wind * 3.6)} km/h</p>`;
                }
                
                if (catchItem.notes) {
                    html += `<p>üìù ${catchItem.notes}</p>`;
                }
                
                html += `
                    </div>
                    <div class="item-actions">
                `;
                
                if (catchItem.photo) {
                    html += `
                        <button class="btn btn-small btn-secondary" onclick="app.viewPhoto('${catchItem.photo}')">
                            <span>üì∑</span> Foto
                        </button>
                    `;
                }
                
                html += `
                        <button class="btn btn-small btn-secondary" onclick="app.navigateToSpot(${catchItem.lat}, ${catchItem.lng})">
                            <span>üó∫Ô∏è</span> Position
                        </button>
                        <button class="btn btn-small btn-danger" onclick="app.deleteCatch(${catchItem.id})">
                            <span>üóëÔ∏è</span> L√∂schen
                        </button>
                    </div>
                `;
                
                el.innerHTML = html;
                return el;
            }

            viewPhoto(photoData) {
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 90%; max-height: 90%;">
                        <div class="modal-header">
                            <h3 class="modal-title">üì∑ Fang-Foto</h3>
                            <button class="modal-close" onclick="this.closest('.modal').remove()">√ó</button>
                        </div>
                        <div class="modal-body" style="text-align: center;">
                            <img src="${photoData}" style="max-width: 100%; max-height: 70vh;" alt="Fang-Foto">
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            async deleteCatch(id) {
                if (!confirm('Fang wirklich l√∂schen?')) return;
                
                try {
                    await this.db.deleteCatch(id);
                    this.showToast('Fang gel√∂scht', 'info');
                    this.updateCatchList();
                } catch (error) {
                    console.error('Fehler beim L√∂schen:', error);
                    this.showToast('L√∂schen fehlgeschlagen', 'error');
                }
            }

            // Backup & Restore
            async backupData() {
                try {
                    const data = await this.db.exportData();
                    const json = JSON.stringify(data, null, 2);
                    
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hochseeangeln-backup-${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    await this.db.saveSetting('lastBackup', new Date().toISOString());
                    this.updateStorageStats();
                    
                    this.showToast('Backup erstellt', 'success');
                } catch (error) {
                    console.error('Fehler beim Backup:', error);
                    this.showToast('Backup fehlgeschlagen', 'error');
                }
            }

            async restoreData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        
                        if (!data.version || !data.markers || !data.catches) {
                            throw new Error('Ung√ºltiges Backup-Format');
                        }
                        
                        if (!confirm('Alle aktuellen Daten werden √ºberschrieben. Fortfahren?')) {
                            return;
                        }
                        
                        // Daten wiederherstellen
                        await this.db.clearAllData();
                        
                        // Marker
                        for (const marker of data.markers) {
                            await this.db.saveMarker(marker);
                        }
                        
                        // F√§nge
                        for (const catchItem of data.catches) {
                            await this.db.saveCatch(catchItem);
                        }
                        
                        // Routen
                        if (data.routes) {
                            for (const route of data.routes) {
                                await this.db.saveRoute(route);
                            }
                        }
                        
                        // Einstellungen
                        if (data.settings) {
                            for (const [key, value] of Object.entries(data.settings)) {
                                await this.db.saveSetting(key, value);
                            }
                        }
                        
                        this.showToast('Daten wiederhergestellt', 'success');
                        
                        // UI neu laden
                        setTimeout(() => {
                            location.reload();
                        }, 1000);
                        
                    } catch (error) {
                        console.error('Fehler beim Wiederherstellen:', error);
                        this.showToast('Wiederherstellung fehlgeschlagen', 'error');
                    }
                };
                
                input.click();
            }

            async exportSpots() {
                try {
                    const spots = await this.db.getMarkers();
                    
                    if (spots.length === 0) {
                        this.showToast('Keine Angelpl√§tze zum Exportieren', 'warning');
                        return;
                    }
                    
                    // GPX-Format
                    const gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Hochseeangeln Leka App">
  <metadata>
    <name>Angelpl√§tze Leka</name>
    <time>${new Date().toISOString()}</time>
  </metadata>
  ${spots.map(spot => `
  <wpt lat="${spot.lat}" lon="${spot.lng}">
    <name>${spot.name}</name>
    ${spot.depth ? `<ele>-${spot.depth}</ele>` : ''}
    <desc>${[
        spot.ground ? `Grund: ${spot.ground}` : '',
        spot.fishTypes?.length ? `Fische: ${spot.fishTypes.join(', ')}` : '',
        spot.notes || ''
    ].filter(Boolean).join(' | ')}</desc>
    <sym>${spot.favorite ? 'Flag' : 'Waypoint'}</sym>
  </wpt>`).join('')}
</gpx>`;
                    
                    const blob = new Blob([gpx], { type: 'application/gpx+xml' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `angelplaetze-leka-${new Date().toISOString().split('T')[0]}.gpx`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast(`${spots.length} Angelpl√§tze exportiert`, 'success');
                } catch (error) {
                    console.error('Fehler beim Exportieren:', error);
                    this.showToast('Export fehlgeschlagen', 'error');
                }
            }

            importSpots() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.gpx,.json';
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        const text = await file.text();
                        let spots = [];
                        
                        if (file.name.endsWith('.gpx')) {
                            // GPX parsen
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(text, 'text/xml');
                            const waypoints = doc.querySelectorAll('wpt');
                            
                            waypoints.forEach(wpt => {
                                const lat = parseFloat(wpt.getAttribute('lat'));
                                const lng = parseFloat(wpt.getAttribute('lon'));
                                const name = wpt.querySelector('name')?.textContent || 'Importierter Platz';
                                const desc = wpt.querySelector('desc')?.textContent || '';
                                const ele = wpt.querySelector('ele')?.textContent;
                                
                                spots.push({
                                    name,
                                    lat,
                                    lng,
                                    depth: ele ? Math.abs(parseFloat(ele)) : null,
                                    notes: desc,
                                    favorite: false,
                                    created: new Date().toISOString()
                                });
                            });
                        } else {
                            // JSON
                            const data = JSON.parse(text);
                            spots = Array.isArray(data) ? data : data.markers || [];
                        }
                        
                        if (spots.length === 0) {
                            throw new Error('Keine Angelpl√§tze gefunden');
                        }
                        
                        // Importieren
                        let imported = 0;
                        for (const spot of spots) {
                            try {
                                await this.map.addMarker(spot);
                                imported++;
                            } catch (error) {
                                console.error('Fehler beim Importieren eines Platzes:', error);
                            }
                        }
                        
                        this.updateSpotsList();
                        this.showToast(`${imported} Angelpl√§tze importiert`, 'success');
                        
                    } catch (error) {
                        console.error('Fehler beim Importieren:', error);
                        this.showToast('Import fehlgeschlagen', 'error');
                    }
                };
                
                input.click();
            }

            testAlerts() {
                // Test-Warnungen
                this.showToast('Info-Meldung', 'info');
                setTimeout(() => this.showToast('Erfolgs-Meldung', 'success'), 500);
                setTimeout(() => this.showToast('Warnung', 'warning'), 1000);
                setTimeout(() => this.showToast('Fehler-Meldung', 'error'), 1500);
                
                // Vibration (falls verf√ºgbar)
                if ('vibrate' in navigator) {
                    navigator.vibrate([200, 100, 200]);
                }
                
                // Test-Ton
                this.weather.playWarningSound();
            }

            async clearAllData() {
                if (!confirm('WARNUNG: Alle Daten werden unwiderruflich gel√∂scht!\n\nWirklich fortfahren?')) {
                    return;
                }
                
                if (!confirm('Letzte Chance - wirklich ALLE Daten l√∂schen?')) {
                    return;
                }
                
                try {
                    await this.db.clearAllData();
                    localStorage.clear();
                    
                    this.showToast('Alle Daten gel√∂scht', 'info');
                    
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                    
                } catch (error) {
                    console.error('Fehler beim L√∂schen:', error);
                    this.showToast('L√∂schen fehlgeschlagen', 'error');
                }
            }

            // Notfall-Funktionen
            activateEmergency() {
                this.isEmergencyMode = true;
                
                // GPS aktivieren falls nicht aktiv
                if (!this.gps.isTracking) {
                    this.startGPS();
                }
                
                // Position anzeigen
                this.updateEmergencyPosition(this.gps.currentPosition);
                
                // Modal √∂ffnen
                document.getElementById('emergencyModal').classList.add('active');
                
                // Kontinuierliche Updates
                this.emergencyInterval = setInterval(() => {
                    this.updateEmergencyPosition(this.gps.currentPosition);
                }, APP_CONFIG.emergencyUpdateInterval);
                
                // Warnung
                if ('vibrate' in navigator) {
                    navigator.vibrate([1000, 500, 1000, 500, 1000]);
                }
                
                this.showToast('NOTFALL-MODUS AKTIVIERT', 'error');
            }

            deactivateEmergency() {
                this.isEmergencyMode = false;
                
                if (this.emergencyInterval) {
                    clearInterval(this.emergencyInterval);
                    this.emergencyInterval = null;
                }
                
                this.closeModal('emergencyModal');
            }

            updateEmergencyPosition(position) {
                if (!this.isEmergencyMode) return;
                
                const coordsEl = document.getElementById('emergencyCoords');
                const updateEl = document.getElementById('emergencyLastUpdate');
                
                if (position && coordsEl) {
                    coordsEl.value = `${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`;
                }
                
                if (updateEl) {
                    updateEl.textContent = `Letzte Aktualisierung: ${new Date().toLocaleTimeString('de-DE')}`;
                }
            }

            sendEmergencyPosition() {
                const coords = document.getElementById('emergencyCoords').value;
                
                if (!coords) {
                    this.showToast('Keine Position verf√ºgbar', 'error');
                    return;
                }
                
                // Text f√ºr Teilen erstellen
                const text = `üÜò NOTFALL - Meine Position: ${coords}\n\nGoogle Maps: https://maps.google.com/?q=${coords}`;
                
                // Web Share API verwenden (falls verf√ºgbar)
                if (navigator.share) {
                    navigator.share({
                        title: 'NOTFALL - Position',
                        text: text
                    }).catch(err => {
                        console.error('Teilen fehlgeschlagen:', err);
                        this.copyToClipboard(text);
                    });
                } else {
                    // Fallback: In Zwischenablage kopieren
                    this.copyToClipboard(text);
                }
            }

            async editSpot(id) {
                try {
                    const spots = await this.db.getMarkers();
                    const spot = spots.find(s => s.id === id);
                    
                    if (!spot) {
                        this.showToast('Angelplatz nicht gefunden', 'error');
                        return;
                    }
                    
                    // Formular mit vorhandenen Daten f√ºllen
                    document.getElementById('markerName').value = spot.name || '';
                    document.getElementById('markerCoords').value = `${spot.lat}, ${spot.lng}`;
                    document.getElementById('markerDepth').value = spot.depth || '';
                    document.getElementById('markerGround').value = spot.ground || '';
                    document.getElementById('markerNotes').value = spot.notes || '';
                    document.getElementById('markerFavorite').checked = spot.favorite || false;
                    
                    // Fischarten ausw√§hlen
                    if (spot.fishTypes) {
                        document.querySelectorAll('#markerFishGrid .fish-species-item').forEach(item => {
                            if (spot.fishTypes.includes(item.dataset.species)) {
                                item.classList.add('selected');
                            }
                        });
                    }
                    
                    // Modal √∂ffnen
                    document.getElementById('markerModal').classList.add('active');
                    
                    // Speichern-Button anpassen f√ºr Update
                    const form = document.getElementById('markerForm');
                    form.dataset.editId = id;
                    
                } catch (error) {
                    console.error('Fehler beim Bearbeiten:', error);
                    this.showToast('Fehler beim Laden der Daten', 'error');
                }
            }

            // Hilfsfunktionen
            copyCoords(elementId) {
                const input = document.getElementById(elementId);
                if (!input) return;
                
                this.copyToClipboard(input.value);
                
                // Button-Feedback
                const button = input.nextElementSibling;
                if (button) {
                    button.classList.add('copied');
                    button.innerHTML = '‚úì';
                    setTimeout(() => {
                        button.classList.remove('copied');
                        button.innerHTML = 'üìã';
                    }, 2000);
                }
            }

            copyToClipboard(text) {
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(text).then(() => {
                        this.showToast('In Zwischenablage kopiert', 'success');
                    }).catch(() => {
                        this.fallbackCopy(text);
                    });
                } else {
                    this.fallbackCopy(text);
                }
            }

            fallbackCopy(text) {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                
                try {
                    document.execCommand('copy');
                    this.showToast('In Zwischenablage kopiert', 'success');
                } catch (err) {
                    this.showToast('Kopieren fehlgeschlagen', 'error');
                }
                
                document.body.removeChild(textarea);
            }

            showToast(message, type = 'info') {
                const container = document.getElementById('toastContainer');
                if (!container) return;
                
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.innerHTML = `<span>${message}</span>`;
                
                container.appendChild(toast);
                
                // Automatisch entfernen
                setTimeout(() => {
                    toast.style.animation = 'slideDown 0.3s ease';
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }, 3000);
            }

            closeModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.remove('active');
                }
            }

            showLoading(show) {
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) {
                    overlay.style.display = show ? 'flex' : 'none';
                }
            }

            showCriticalError(message) {
                const errorEl = document.getElementById('criticalError');
                const messageEl = document.getElementById('criticalErrorMessage');
                
                if (errorEl && messageEl) {
                    messageEl.textContent = message;
                    errorEl.classList.add('active');
                }
                
                // Auch in Konsole ausgeben
                console.error('KRITISCHER FEHLER:', message);
            }

            hasUnsavedChanges() {
                // Pr√ºfen ob ungespeicherte √Ñnderungen vorliegen
                return this.route.isRecording || this.isEmergencyMode;
            }

            // Service Worker
            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        // Service Worker Code inline definieren
                        const swCode = `
self.addEventListener('install', event => {
    event.waitUntil(
        caches.open('hochseeangeln-v1').then(cache => {
            return cache.addAll([
                '/',
                'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
                'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
                'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'
            ]);
        })
    );
});

self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request).then(response => {
            return response || fetch(event.request);
        })
    );
});
                        `;
                        
                        const blob = new Blob([swCode], { type: 'application/javascript' });
                        const swUrl = URL.createObjectURL(blob);
                        
                        await navigator.serviceWorker.register(swUrl);
                        console.log('Service Worker registriert');
                        
                    } catch (error) {
                        console.error('Service Worker Registrierung fehlgeschlagen:', error);
                    }
                }
            }

            // Offline-√úberwachung
            monitorOfflineStatus() {
                const updateStatus = () => {
                    const banner = document.getElementById('offlineBanner');
                    if (banner) {
                        banner.classList.toggle('active', !navigator.onLine);
                    }
                    
                    if (!navigator.onLine) {
                        this.showToast('Offline-Modus aktiviert', 'warning');
                    }
                };
                
                window.addEventListener('online', updateStatus);
                window.addEventListener('offline', updateStatus);
                
                // Initial pr√ºfen
                updateStatus();
            }

            // Autosave
            startAutosave() {
                this.autosaveInterval = setInterval(() => {
                    this.performAutosave();
                }, APP_CONFIG.autosaveInterval);
            }

            async performAutosave() {
                try {
                    // Sync-Status anzeigen
                    const indicator = document.getElementById('syncIndicator');
                    const status = document.getElementById('syncStatus');
                    
                    if (indicator) indicator.classList.add('syncing');
                    if (status) status.textContent = 'Synchronisiere...';
                    
                    // Wichtige Daten sichern
                    if (this.gps.trackPoints.length > 0) {
                        await this.db.saveGPSTrack({
                            points: this.gps.trackPoints,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    // Wetter cachen
                    if (this.weather.currentWeather) {
                        await this.weather.cacheWeather();
                    }
                    
                    // Status zur√ºcksetzen
                    setTimeout(() => {
                        if (indicator) indicator.classList.remove('syncing');
                        if (status) status.textContent = 'Daten gesichert';
                    }, 1000);
                    
                } catch (error) {
                    console.error('Autosave-Fehler:', error);
                    
                    const indicator = document.getElementById('syncIndicator');
                    if (indicator) indicator.classList.add('error');
                }
            }

            // Statistiken
            updateStatistics() {
                // Wird von den jeweiligen Update-Funktionen aufgerufen
                this.updateSpotsList();
                this.updateCatchList();
                this.updateStorageStats();
            }
        }

        // ====================================
        // APP INITIALISIERUNG
        // ====================================
        let app; // Global variable declaration
        
        // Warten bis DOM geladen ist
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                app = new HochseeangelnApp();
                window.app = app; // Make globally available
                app.init();
            });
        } else {
            app = new HochseeangelnApp();
            window.app = app; // Make globally available
            app.init();
        }
    </script>
</body>
</html>